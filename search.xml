<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TextView自动换行]]></title>
    <url>%2F2019%2F01%2F13%2FTextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[前言TextView可以说是在Android中最常用的控件之一了。但是Text View中也有很多的坑，其中之一就是自动换行。 问题上面是网易新闻的列表截图，可以看到，“韩媒：中国已经抄袭了我们34个综”后面就进行换行了，给后面留下了较多的空白。像这种图片较多，每行之间间隔较大的列表来说也不是很明显。但像下面这种就显得比较难看了。 初步解决方案想到的思路是自己重写TextView的onDraw方法，只有到文字超出控件宽度时才换行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AlignText extends TextView &#123; private float textSize; private int textColor; private int paddingRight; private int paddingLeft; private float lineSpacing; private Paint paint; public AlignText(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); textSize = getTextSize(); textColor = getCurrentTextColor(); paddingLeft = getPaddingLeft(); paddingRight = getPaddingRight(); lineSpacing = getLineSpacingExtra(); &#125; protected void onDraw(Canvas canvas) &#123; if (paint == null) &#123; paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); &#125; int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; for (int i = 0; i &lt; textCharArray.length; i++) &#123; if (textCharArray[i] == &apos;\n&apos;) &#123; lineCount++; drawWidth = 0; continue; &#125; charWidth = paint.measureText(textCharArray, i, 1); if (textShowWidth - drawWidth &lt; charWidth) &#123; lineCount++; drawWidth = 0; &#125; float x=drawWidth + paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); canvas.drawText(textCharArray, i, 1, x, y, paint); drawWidth += charWidth; &#125; &#125;&#125; 存在的不足由上节代码可以看到，AlignText是在计算每一个字符的长度后判断是否需要换行。但是当一段文字中出现中英文或者标点符号时，由于不同的字符之间的宽度不同，在一段文字右侧也不能够完全对齐。 思考完善要解决上面提到的问题，我想到了两种方法： 由于单个汉字所占用空间是最大的，所以将所有的单个字符的宽度都设置为统一的宽度。 将最后的空白分配到之前的每一个字符的间隔之间。 方案一：123456789101112131415161718192021222324252627282930313233protected void onDraw(Canvas canvas)&#123; if (paint == null) &#123; paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); &#125; int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = paint.measureText(&quot;啊&quot;); for (int i = 0; i &lt; textCharArray.length; i++) &#123; if (textCharArray[i] == &apos;\n&apos;) &#123; lineCount++; drawWidth = 0; continue; &#125; if (textShowWidth - drawWidth &lt; charWidth) &#123; lineCount++; drawWidth = 0; &#125; float x=drawWidth + paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); canvas.drawText(textCharArray, i, 1, x, y, paint); drawWidth += charWidth; &#125;&#125;``` 效果&lt;img align=&quot;middle&quot; src=&quot;https://www.sisyphuser.cn/images/see/TextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C_4.jpg&quot;/&gt;&lt;/br&gt;方案二： protected void onDraw(Canvas canvas){ if (paint == null) { paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); } int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; int start = 0; int end = 0; for (int i = 0; i &lt; textCharArray.length; i++) { end++; if(i==textCharArray.length-1){ float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } if (textCharArray[i] == ‘\n’) { if (end-1 &gt; start) { float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } lineCount++; drawWidth = 0; start=i+1; continue; } charWidth = paint.measureText(textCharArray, i, 1); if (textShowWidth - drawWidth &lt; charWidth) { float addSpacing = (textShowWidth - drawWidth)/(end-2-start); float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize/8) (lineCount - 1)); int innerDrawWidth=0; for(int j= 0;j&lt;end-1-start;j++) { canvas.drawText(textCharArray, start+j, 1, x+innerDrawWidth+j*addSpacing, y, paint); float tempCharWidth=paint.measureText(textCharArray, start+j, 1); innerDrawWidth+=tempCharWidth; } lineCount++; drawWidth = 0; start=i; } drawWidth += charWidth; } }12345678效果&lt;img align=&quot;middle&quot; src=&quot;https://www.sisyphuser.cn/images/see/TextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C_6.jpg&quot;/&gt;&lt;/br&gt;### emoji问题在解决完对齐问题后发现了一个bug。原本能显示的emoji表情由于每次分开绘制字符变成了两个乱码符号。从[Emoji的编码以及常见问题处理](https://segmentfault.com/a/1190000007594620?utm_source=tuicool&amp;utm_medium=referral)中了解到一个emoji占了两个长度，而我把它截断了自然就显示乱码了。&lt;/br&gt;解决方案：对emoji的两个字符一起绘制，emoji的编码为(&apos;u&apos;\ud83c[\udf00-\udfff] | &apos;u&apos;\ud83d[\udc00-\ude4f\ude80-\udeff] | &apos;u&apos;[\u2600-\u2B55]) protected void onDraw(Canvas canvas){ if (paint == null) { paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); } int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; int start = 0; int end = 0; int defaultCount = 1; for (int i = 0; i &lt; textCharArray.length; i+=defaultCount) { end+=defaultCount; Log.i(“ssss”,String.valueOf(textCharArray[i])+defaultCount); if (textCharArray[i] == ‘\n’) { if (end-1 &gt; start) { float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } lineCount++; drawWidth = 0; start=i+1; defaultCount = 1; continue; } int index=(int)textCharArray[i]; if(i&lt;textCharArray.length-1 &amp;&amp;(index == 0xd83c ||index == 0xd83d || (index &gt;= 0x2600 &amp;&amp; index &lt;= 0x2B55))) { defaultCount = 2; }else{ defaultCount = 1; } charWidth = paint.measureText(textCharArray, i, defaultCount); if (textShowWidth - drawWidth &lt; charWidth) { float addSpacing = (textShowWidth - drawWidth)/(end-2-start); float x = paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); int innerDrawWidth=0; int innerDefaultCount = 1; for(int j= 0;j&lt;end-1-start;j+= innerDefaultCount) { int innerIndex=(int)textCharArray[start+j]; if(i&lt;textCharArray.length-1 &amp;&amp;(innerIndex == 0xd83c ||innerIndex == 0xd83d || (innerIndex &gt;= 0x2600 &amp;&amp; innerIndex &lt;= 0x2B55))){ innerDefaultCount = 2; }else{ innerDefaultCount = 1; } canvas.drawText(textCharArray, start+j, innerDefaultCount, x+innerDrawWidth+j*addSpacing, y, paint); float tempCharWidth=paint.measureText(textCharArray, start+j, innerDefaultCount); innerDrawWidth+=tempCharWidth; } lineCount++; drawWidth = 0; start=i; } if(i==textCharArray.length-defaultCount){ float x = paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize / 8) * (lineCount - 1)); canvas.drawText(textCharArray, start, textCharArray.length - start, x, y, paint); } drawWidth += charWidth; } }`]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS介绍]]></title>
    <url>%2F2018%2F07%2F20%2FHTTPS%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。接下来我会简单介绍一下https的通讯过程。 实现原理http默认使用80端口https默认使用443端口HTTPS 协议主要是为了保护用户隐私，防止流量劫持。https其实就是一个添加了加密认证的http，应用到了非对称加密和对称加密。关于非对称加密和对称加密的区别可以参考这个。 握手过程整个握手的过程可由下图表示 每个步骤传递的数据1.客户端发起请求，传输随机数、加密套件、支持的TLS协议版本等 2.服务端返回，随机数、选择一个支持的协议版本、加密证书 3.与CA验证证书有效性 4.客户端请求，生成随机数结合前两个随机数和约定的算法生成密钥，使用证书中的公钥加密传输生成的随机数 5.服务端，使用私钥获取加密传输中的随机数，用三个随机数和约定好的算法生成密钥，使用密钥用对称加密与客户端通讯验证 6.握手结束，使用密钥进行http加密通讯 参考大型网站的 HTTPS 实践（一）– HTTPS 协议和原理HTTPS协议详解(四)：TLS/SSL握手过程]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android6.0权限管理]]></title>
    <url>%2F2018%2F04%2F10%2FAndroid6.0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言Android6.0(API 23)引入了一种新的权限模式，即运行时应用权限管理。这种模式让用户能够更好地了解和控制权限，用户可为所安装的各个应用分别授予或撤销权限。对于开发者来说意味着在使用对应权限功能时必须要先判断权限是否已经赋予了。 危险权限对于权限的管理，并不是所有的权限都需要用户允许的，只有一部分危险权限需要许可。可以参照下图 检查、请求权限 在AndroidManifest中添加所需的权限 在使用危险权限功能前检查权限的状态 1checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED 当没有权限(检查权限状态不为PackageManager.PERMISSION_GRANTED)时请求权限 1requestPermissions(new String[]&#123;Manifest.permission.ACCESS_COARSE_LOCATION&#125;, 1); 在用户操作回掉中处理允许和拒绝操作的逻辑 12345678910111213@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;允许定位权限&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, &quot;拒绝定位权限！！！&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 其中在第三步中requestPermissions()可以一次请求多个权限，对于那些用户已经允许和拒绝并且勾选了不再提示的权限会直接执行回掉，并不会让用户再次选择授权。所以对于那些必须要要权限才能使用的功能可以在用户拒绝之后让用户在设置中手动打开权限。 123Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);intent.setData(Uri.fromParts(&quot;package&quot;, getPackageName(), null));startActivity(intent); 对于特殊机型的适配由于国内很多手机厂商早在Android6.0之前就有了自己的权限管理系统，在Android6.0之后有一些还保留着原有的权限管理系统。这导致了明明用checkSelfPermission()检查有权限但还是还是无法使用权限功能。例如VIVO在所有情况下checkSelfPermission()都是返回有权限，但他在使用到有关权限操作时会自动提示用户权限许可。不过这种情况下调用并不会导致系统报错，而且第三方厂商也做了使用权限的提示。下面以小米为例判断是否在小米中打开权限 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/***检查是由有权限**/private static boolean checkOpsPermission(Context context, String permission) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; try &#123; AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); String opsName = AppOpsManager.permissionToOp(permission); if (opsName == null) &#123; return true; &#125; int opsMode = appOpsManager.checkOpNoThrow(opsName, android.os.Process.myUid(), context.getPackageName()); return opsMode == AppOpsManager.MODE_ALLOWED; &#125; catch (Exception ex) &#123; return true; &#125; &#125; else &#123; return true; &#125;&#125;/** * 打开小米权限设置 */public void openPermissionSetting(Activity activity) &#123; String miuiVersion = getMiuiVersion(); Intent intent = null; if (&quot;V5&quot;.equals(miuiVersion)) &#123; Uri packageURI = Uri.parse(&quot;package:&quot; + activity.getApplicationInfo().packageName); intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI); &#125; else if (&quot;V6&quot;.equals(miuiVersion) || &quot;V7&quot;.equals(miuiVersion)) &#123; intent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); intent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;); intent.putExtra(&quot;extra_pkgname&quot;, activity.getPackageName()); &#125; else if (&quot;V8&quot;.equals(miuiVersion) || &quot;V9&quot;.equals(miuiVersion)) &#123; intent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); intent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;); intent.putExtra(&quot;extra_pkgname&quot;, activity.getPackageName()); &#125; if (null != intent) activity.startActivity(intent);&#125;/** * 获取MIUI版本 */public String getMiuiVersion() &#123; String line; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec(&quot;getprop ro.miui.ui.version.name&quot;); input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; return null; &#125; finally &#123; if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; return line;&#125; 参考Android 6.0 运行时权限处理完全解析权限最佳做法Android 6.0动态权限及小米（MIUI）权限的特殊处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令(下)]]></title>
    <url>%2F2018%2F04%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[前言在Git常用命令（上）中记录了一些添加提交文件的命令，而这篇将介绍一些关于版本回滚和分支管理的命令。 版本回退当发现新提交的版本有问题或者需要查看之前版本时可以使用版本回退功能。1git reset --hard HEAD 其中HEAD可以用提交时的版本号代替，可以是当前版本之前和之后的版本。 这是一个危险操作，他会替换掉工作区、暂存区和本地库中的内容，工作区和暂存区的内容将无法找回，本地库中的内容可以通过1git reset --hard &lt;版本号&gt; 找回，版本号可以通过 git reflog 来查找。使用 git reset –hard HEAD 回退后，在本地库中指针已经指向了对应的HEAD，需要把他同步到远程库。但是这时发现push到远程库失败， 原因是本地库比远程库的版本低（那是当然，刚才做了版本回退了啊），也不能执行pull，否则之前的操作就白费了。解决的办法是使用强制提交1git push -f origin master 除了用reset之外还可以使用revert进行回退1git revert &lt;版本号&gt; reset与revert的区别在与reset 是把HEAD向后移动了一下，而revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 分支在多人协作的开发中，需要有一个规范的工作流程。关于工作流程可以参考Git 工作流程,下面将介绍一些关于工作流程中分支的用法。1git branch &lt;branchName&gt; 创建分支1git checkout &lt;branchName&gt; 切换分支1git checkout -b &lt;branchName&gt; 创建并切换分支1git branch -d &lt;branchName&gt; 删除分支1git branch 查看全部分支，在当前分支前加上*1git merge &lt;branchName&gt; 将指定分支合并到当前分支1it merge --no-ff -m &quot;提交信息&quot; &lt;branchName&gt; 将指定分支合并到当前分支禁用 fast forward ,用这种方式提交会在当前分支生成一个合并分支的记录，方便之后的问题排查。1git rebase &lt;branchName&gt; 并入分支，这个和merge执行后的结果一致，但是实现的原理不同。merge只是合并分支，合并后当前分支的历史不变，只会新增目标分支的新的提交。而rebase则是先找到分支的起点，再将目标分支对应起点之后的各版本提交，然后提交当前分支对应起点的各版本。显然这会改变当前分支的历史，将不属于该分支的版本加入到当前分支中，会增加排查问题的难度。并入过程中可能会多次遇到冲突，可以在解决冲突后使用12git add .git rebase --continue 依次解决。rebase 需要遵循原则，即绝不要在公共的分支上使用它。1git log --graph --pretty=oneline --abbrev-commit 查看分支合并情况 blame1git blame &lt;fileName&gt; 用来查询该文件的修改记录 标签在每次发布版本或者新增重大功能时可以打上标签以方便以后的查询。1git tag &lt;tagName&gt; 创建标签1git tag -d &lt;tagName&gt; 删除标签1git push origin &lt;tagName&gt; 将标签推送到远程库 参考廖雪峰Git教程远程仓库版本回退方法Git分支管理策略代码合并：Merge、Rebase 的选择]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令(上)]]></title>
    <url>%2F2018%2F03%2F27%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[前言Git是一个优秀分布式版本控制系统，可以有效、高速的处理项目版本管理。在日常开发过程中经常会与之打交道，所以在下面记录了一些常用的Git命令。 创建ssh的公钥和私钥在git bush中输入1ssh-keygen -t rsa -C &quot;email@163.com&quot; 之后会需要输入保存key个文件位置和密码，这些都可以直接回车，默认的可以位置在C://用户/user/.ssh其中id_rsa.pub为公钥，id_rsa为私钥 以GitHub为例上传公钥再将公钥中的内容全部复制提交就可以了 设置git提交时的个人信息查看git基本信息配置1git config -l 设置显示的用户名1git config --global user.name &quot;Your Name&quot; 设置显示的邮箱1git config --global user.email &quot;email@163.com&quot; 关联远程库首先我们需要在GitHub上创建一个git库，这个很简单只要选择New repository然后按提示下一步就可以了。现在有了一个远程库，需要将本地的文件夹与他关联起来。注意在这里有两个远程库的地址 分别是”https://github.com...&quot;和&quot;git@github.com...&quot;。这两者的区别是”https://github.com...&quot;在每次执行需要权限的操作时都需要输入用户名和密码，而&quot;git@github.com...&quot;则需要先配置好SSH这就是第二部的操作，所以我选择使用&quot;git@github.com...&quot;来关联远程库。有两种关联的方法： 1) 如果没有本地文件可以直接clone1git clone git@github.com... 2) 如果有本地文件则可以在文件所在文件夹中执行1git init 创建本地库1git remote add origin git@github.com... 关联远程库 添加一个文件需要新增或修改一个文件时需要执行两部操作：add和commitadd:将工作区添加一个新建或修改的文件到暂存区1git add &lt;filename&gt; 添加特定的文件12git add --allgit add -A 添加所有的文件commit:将暂存区的文件提交到版本库中1git commit -m &quot;提交说明&quot; 当然也可以把两部操作合并1git commit -am &quot;提交说明&quot; 但是这个只适用于添加文件修改，对于新增的文件并不能添加。 关于.gitignore的使用.gitignore其实就是一个git的忽略文件。一般的匹配规则有三种： /filename/ 忽略目标文件夹 *.class 忽略所有匹配的.class文件 Test.class 忽略精确匹配的Test.class文件 当在.gitignore中声明了忽略文件后在git add –all中就会被跳过，也无法通过 git add 添加，但是可以使用 git add -f 强制添加。值得注意的是当一个文件已经被添加了，在暂存区中存在时，即使在.gitignore中声明了忽略也对这个文件无效。解决的方法是使用1git rm --cached -- &lt;filename&gt; 在暂存区中移除该文件。 工作区和暂存区对于工作区和暂存区简单的来说就是在add之前所有的变动操作都是在工作区，当add对文件生效后他就在暂存区了，commit提交的内容都只是暂存区的变更内容。关于工作区、暂存区和版本库之间的操作： 将工作区的更改保存到暂存区 1git add 将暂存区的更改保存到版本库 1git commit 从暂存区中删除文件而工作区不做更改 1git rm --cached -- &lt;filename&gt; 将暂存区的全部/指定文件替换工作区的文件 1git checkout . / git checkout -- &lt;filename&gt; 将版本库中全部/指定文件替换暂存区和工作区的文件 1git checkout HEAD . / git checkout HEAD &lt;filename&gt; 将版本库中全部/指定文件替换暂存区的文件而工作区不做更改 1git reset HEAD . / git reset HEAD &lt;filename&gt; 可以用一张图来直观地展示 一些查看Git状态的命令 查看工作区修改的内容 1git diff 查看提交的日志 1git log 查看提交的日志精简 1git log --pretty=oneline 查看每一次的命令及对应改动的版本 1git reflog 参考：Git工作区、暂存区和版本库廖雪峰Git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView的使用]]></title>
    <url>%2F2018%2F03%2F04%2FSurfaceView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在Android中更新UI操作都需要在主线程中操作。但是SurfaceView例外，他可以在子线程中更新View，这使他可以做一些复杂的动画更新而不必担心造成主线程的阻塞。接下来就开始介绍一下SurfaceView的使用。 实现SurfaceView通过SurfaceHolder.Callback来通知SurfaceView的创建和销毁12345678910111213surfaceView.holder.addCallback(object :SurfaceHolder.Callback&#123; //改变 override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; //销毁 override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; //创建 override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125;) 在SurfaceView创建完成之后就可以对其进行绘制了，而他的绘制是可以放在子线程中的 1234//获取画布val canvas=surfaceView.holder.lockCanvas()//提交画布surfaceView.holder.unlockCanvasAndPost(canvas) 创建动画下面就是一个使用SurfaceView创建动画的简单示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MainActivity : Activity() &#123; var surfaceView: SurfaceView? = null var mPath = Path() var mPaint = Paint(Paint.ANTI_ALIAS_FLAG) var mCanvas: Canvas? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) surfaceView = findViewById(R.id.surface_view) surfaceView.holder.addCallback(object:SurfaceHolder.Callback&#123; override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; mPaint.color = Color.BLACK mPaint.style = Paint.Style.STROKE mPaint.strokeWidth = 10f mPaint.strokeCap = Paint.Cap.ROUND mPaint.strokeJoin = Paint.Join.ROUND mPath.moveTo(0f, 100f) Thread(Runnable &#123; kotlin.run &#123; draw(0) &#125; &#125;).start() &#125; &#125;) &#125; private fun draw(x: Int) &#123; if (x &gt; 1080) &#123; return &#125; val y = (50 * Math.sin(x * Math.PI / 180) + 100).toInt() mPath.lineTo(x + 3f, y.toFloat()) try &#123; mCanvas = holder.svView.holder.lockCanvas() mCanvas?.drawColor(Color.WHITE) mCanvas?.drawPath(mPath, mPaint) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; if (mCanvas != null) holder.svView.holder.unlockCanvasAndPost(mCanvas) &#125; draw(x + 3) &#125;&#125; 其他用途SurfaceView还可以和MediaPlayer一起使用实现视频播放，以下就是简单的示例： 12345678910111213141516171819202122232425262728293031class MainActivity : Activity() &#123; var surfaceView: SurfaceView? = null val url = &quot;https://apd-fec3435b8e24a9f3815c886baf4b7682.v.smtcdns.com/om.tc.qq.com/A3h5f3r8PilbVshgbDGWN3dyaZ8zUFk92BfD1Npo4MBA/h0560ixm63g.mp4?sdtfrom=v1103&amp;guid=2cd4a548b5a2146345f8214435e93e24&amp;vkey=10A496F49B3530CF50C56B617F6DB75C6A69850F6E8AD27EF01C74C9B06E07A95E952146937CD25966DF570C447F3AA1570F392682DEEDA0953F1CA68941B5C3FD7552C0D4DC7666322C5B6EF983BCB32A09AD04252FD6CB536BBBB81CC1BAD7CB31E90E1D341D675E08ED216DCA77E0D868B2EE67C3D6F5&amp;platform=2&quot; val player = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) surfaceView = findViewById(R.id.surface_view) Thread(Runnable &#123; player.setDataSource(this, Uri.parse(url)) player.prepare() &#125;).start() surfaceView.holder.addCallback(object:SurfaceHolder.Callback&#123; override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; player.setDisplay(holder) &#125; &#125;) player.setOnPreparedListener(object : MediaPlayer.OnPreparedListener &#123; override fun onPrepared(p0: MediaPlayer?) &#123; player.start() player.isLooping = true &#125; &#125;) &#125;&#125; 参考SurfaceViewAndroid之SurfaceView使用总结Android SurfaceView的使用android中使用surfaceview＋MediaPlayer播放视频]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>SurfaceView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio自定义模板]]></title>
    <url>%2F2017%2F12%2F07%2FAndroid%20Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[前言在Android Studio如果我们需要新建一个Activity一般都会new一个Empty Activity。然而新建出来的结果往往还不是我们需要的，还需要进行一些修改。比如说Activity默认是继承AppCompatActivity而一般我都习惯写一个统一的父类来继承，并且在Activity中做一些初始化的操作，如果使用MVP模式还需要新建一个Presenter类。对于这些需求我一直都是在创建完后再进行修改和新建，直到我我看到了Android Studio的自定义模板。 目录文件首先我们找到AS默认模板的存放路径AS3.0\android-studio\plugins\android\lib\templates其中我们平时常用的模板就放在activity和other这两个文件夹下。先以最简单的EmptyActivity为例，他的结构目录是 root SimpleActivity.java.ftl SimpleActivity.kt.ftl globals.xml.ftl recipe.xml.ftl template.xml templat_black_activity.png 其中root目录下是模板ftl文件globals.xml.ftl是全局参数配置文件recipe.xml.ftl是控制文件创建和修改template.xml和templat_black_activity.png是创建时的UI界面控制 template.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template format=&quot;5&quot; revision=&quot;5&quot; name=&quot;TheMVP Activity&quot; minApi=&quot;9&quot; minBuildApi=&quot;14&quot; description=&quot;Creates a new empty activity with TheMVP&quot;&gt; &lt;category value=&quot;Activity&quot; /&gt; &lt;formfactor value=&quot;Mobile&quot; /&gt; &lt;parameter id=&quot;activityClass&quot; name=&quot;Activity Name&quot; type=&quot;string&quot; constraints=&quot;class|unique|nonempty&quot; suggest=&quot;$&#123;layoutToActivity(layoutName)&#125;&quot; default=&quot;MainActivity&quot; help=&quot;The name of the activity class to create&quot; /&gt; &lt;parameter id=&quot;delegateClass&quot; name=&quot;Delegate Name&quot; type=&quot;string&quot; constraints=&quot;class|unique|nonempty&quot; default=&quot;MainDelegate&quot; visibility=&quot;isCreateDelegate&quot; help=&quot;The name of the delegate class to create&quot; /&gt; &lt;parameter id=&quot;layoutName&quot; name=&quot;Layout Name&quot; type=&quot;string&quot; constraints=&quot;layout|unique|nonempty&quot; suggest=&quot;$&#123;activityToLayout(activityClass)&#125;&quot; default=&quot;activity_main&quot; visibility=&quot;isCreateDelegate&quot; help=&quot;The name of the layout to create for the activity&quot; /&gt; &lt;parameter id=&quot;linkedDelegate&quot; name=&quot;Linked Delegate&quot; type=&quot;string&quot; constraints=&quot;nonempty&quot; default=&quot;AppDelegate&quot; visibility=&quot;!isCreateDelegate&quot; help=&quot;Chose exists delegate&quot;/&gt; &lt;parameter id=&quot;isCreateDelegate&quot; name=&quot;Create Delegate&quot; type=&quot;boolean&quot; default=&quot;true&quot; help=&quot;If false, this delegate and layout will not be created&quot; /&gt; &lt;parameter id=&quot;packageName&quot; name=&quot;Package name&quot; type=&quot;string&quot; constraints=&quot;package&quot; default=&quot;com.mycompany.myapp&quot; /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=&quot;globals.xml.ftl&quot; /&gt; &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt;&lt;/template&gt; 上面就是template.xml和对应的创建UI示图。 template标签主要显示一些名称、描述和一些需要的版本信息，这里我写的测试模板名称为TheMVP Activity。 &lt; category value=”Activity” /&gt; 说明该标签放在Activity目录下，如果设置为Fragment则放在Fragment目录先下。 parameter标签就是主要的创建item的标签了 123456&lt;parameter id=&quot;packageName&quot; name=&quot;Package name&quot; type=&quot;string&quot; constraints=&quot;package&quot; default=&quot;com.mycompany.myapp&quot; /&gt; 这个是默认的选择包名的parameter 123456&lt;thumbs&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=&quot;globals.xml.ftl&quot; /&gt; &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt; 这三个是配置外部关联文件，template_blank_activity.png就显示在UI示图左边，globals.xml.ftl和recipe.xml.ftl将会在下面提到。 globals.xml.ftl1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;globals&gt;&lt;#if isCreateDelegate&gt; &lt;global id=&quot;superClass&quot; type=&quot;string&quot; value=&quot;ActivityPresenter&amp;lt;$&#123;delegateClass&#125;&amp;gt;&quot; /&gt;&lt;#else&gt; &lt;global id=&quot;superClass&quot; type=&quot;string&quot; value=&quot;ActivityPresenter&amp;lt;$&#123;linkedDelegate&#125;&amp;gt;&quot; /&gt;&lt;/#if&gt; &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt; &lt;global id=&quot;parentActivityClass&quot; value=&quot;&quot; /&gt; &lt;global id=&quot;simpleLayoutName&quot; value=&quot;$&#123;layoutName&#125;&quot; /&gt; &lt;global id=&quot;excludeMenu&quot; type=&quot;boolean&quot; value=&quot;true&quot; /&gt; &lt;global id=&quot;generateActivityTitle&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt; &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;&lt;/globals&gt; globals.xml.ftl中的内容比较简单，就是一些全局使用的值。这里有一个简单的逻辑标签123&lt;#if Boolean&gt;&lt;#else&gt;&lt;/#if&gt; rootroot目录下方的是一些作为模板的activity、layout、fragment文件 12345678910111213141516171819202122232425262728293031323334package $&#123;packageName&#125;.activityimport android.app.Activityimport android.content.Intentimport android.os.Bundleimport $&#123;applicationPackage&#125;.base.ActivityPresenter&lt;#if isCreateDelegate&gt;import $&#123;packageName&#125;.delegate.$&#123;delegateClass&#125;&lt;#else&gt;import $&#123;packageName&#125;.delegate.$&#123;linkedDelegate&#125;&lt;/#if&gt;class $&#123;activityClass&#125; : $&#123;superClass&#125;() &#123;&lt;#if isCreateDelegate&gt; override fun instanceDelegate(): $&#123;delegateClass&#125; &#123; return $&#123;delegateClass&#125;() &#125;&lt;#else&gt; override fun instanceDelegate(): $&#123;linkedDelegate&#125; &#123; return $&#123;linkedDelegate&#125;() &#125;&lt;/#if&gt; companion object &#123; fun start(activity: Activity) &#123; val intent=Intent(activity,$&#123;activityClass&#125;::class.java) start(activity,intent) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125;&#125; 写法也比较简单，与正常的代码一样，只是在一些位置将之前template.xml和globals.xml.ftl中输入和定义的值用${id}代替 recipe.xml.ftl123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot;?&gt;&lt;recipe&gt;&lt;#if generateKotlin&gt; &lt;instantiate from=&quot;root/src/app_package/SimpleActivity.kt.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.kt&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.kt&quot; /&gt; &lt;#if isCreateDelegate&gt; &lt;instantiate from=&quot;root/src/app_package/SimpleDelegate.kt.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/delegate/$&#123;delegateClass&#125;.kt&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/delegate/$&#123;delegateClass&#125;.kt&quot; /&gt; &lt;instantiate from=&quot;root/src/app_package/activity_simple.xml.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt; &lt;/#if&gt;&lt;/#if&gt; &lt;merge from=&quot;root/AndroidManifest.xml.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;&lt;/recipe&gt; recipe是一个管理创建的文件，主要用到的操作标签有： copy：从root文件夹复制文件到目标文件夹 instantiate：从root中将对应的ftl文件经处理后转为目标文件 open：打开目标文件 merge：合并文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>自定义模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2使用]]></title>
    <url>%2F2017%2F03%2F16%2FDagger2%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[dagger2是一个依赖注入框架，可以用于功能模块的解耦，非常适合于和MVP搭配使用，下面就来介绍一下dagger2一些使用方式 导入项目库123456789dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;&#125;apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies &#123; compile &apos;com.google.dagger:dagger:2.4&apos; apt &apos;com.google.dagger:dagger-compiler:2.4&apos; compile &apos;org.glassfish:javax.annotation:10.0-b28&apos;&#125; 先来看一个简单的例子： 1234public class MainActivity extends AppCompatActivity &#123; @Inject B b;&#125; 在一个Activity中我需要一个B的实例，通常情况下我们直接b=new B();这样来初始化，但是使用了Dagger2之后就只需要添加一个@Inject注解就可以了。难道这样就可以了吗？不不不，我们还需要做一些配置 创建我们的测试类B 123456789101112public class B &#123; C c; @Inject public B(C c) &#123; this.c = c; &#125; public String geti() &#123; return &quot;result&quot;; &#125;&#125; 等等，这里只有一个构造方法，并且要传入C类，这个C类又是什么。我们一步步来，可以看到在构造方法上有一个@Inject，这个注解和MainActivity中的注解名称一样但是功能是不同的。在MainActivity中放在成员变量上面，是告诉dagger2我需要一个B的实例。在B中放在构造函数上面，是告诉dagger2可以用这个构造函数来创建B的实例。接下来就需要一个中间类来连接MainActivity和B，提供B的初始化条件C 创建MyComponent 1234 @Component(modules = MyModule.class)public interface MyComponent &#123; void inject(MainActivity a);&#125; 这里用到了@Component注解，告诉dagger2需要用到哪些Module 创建MyModule 123456public class MyModule &#123; @Provides public C provideB()&#123; return new C(); &#125;&#125; 提供了C类的实例 在MainActivity中初始化 1DaggerMyComponent.builder().myModule(new MyModule()).build().inject(this); DaggerMyComponent如果没有找到，可以build一下项目，这是一个由dagger2创建的实现了MyComponent的类 简单说先dagger2找到类的实例的基本步骤1. 查找Module中是否存在创建该类的方法。2. 若存在创建类方法，查看该方法是否存在参数2.1 若存在参数，则按从步骤1开始依次初始化每个参数2.2 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束3. 若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数3.1 若存在参数，则从步骤1开始依次初始化每个参数3.2 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 Qualifier(限定符)解决依赖注入迷失什么是依赖迷失？ 12345678910111213141516public class B &#123; C c; @Inject public B() &#123; &#125; @Inject public B(C c) &#123; this.c = c; &#125; public String geti() &#123; return &quot;result&quot;; &#125;&#125; 想上面的这种写法，当一个类中有两个或两个以上的构造方法时，dagger2就不知道用哪个构造方法来创建对象，这事就依赖迷失。当出现依赖迷失时项目编译时就会报错。Qualifier这时就可以发挥他的作用了，关于Qualifier有两种基本的用法 使用@Named注解在Module中 1234567891011@Provides@Named(&quot;c&quot;)public B provideB1(C c)&#123; return new B(c);&#125;@Provides@Named(&quot;qualifier&quot;)public B provideB2(C c)&#123; return new B();&#125; 在MainActivity中 123@Inject@Named(&quot;qualifier&quot;)B b; 自定义Qualifier注解创建注解 12345@Qualifier@Documented@Retention(RUNTIME)public @interface HasC &#123;&#125; 在Module中使用 1234567891011@Provides@HasCpublic B provideB1(C c)&#123; return new B(c);&#125;@Provides@NoCpublic B provideB2()&#123; return new B();&#125; 在MainActivity中使用 123@Inject@HasCB b; Component组织方式 依赖方式如上图中E的创建需要依赖C,F两个条件 1234567891011121314151617181920212223242526272829@Singleton@Component(modules = CModule.class)public interface AppComponent &#123; C c();&#125;@Modulepublic class CModule &#123; @Provides public C getc()&#123; return new C(); &#125;&#125;@UserScope@Component(dependencies = AppComponent.class,modules = BModule.class)public interface MainComponent &#123; void infect(MainActivity a);&#125;@Modulepublic class BModule &#123; @Provides @UserScope public B getb(C c)&#123; return new B(c); &#125;&#125; 在上述案例中MainComponent中的B创建需要依赖与AppComponent中的CModule，所以在MainComponent中添加AppComponent依赖dependencies = AppComponent.class，并在AppComponent中将C暴露出来 初始化，一般将AppComponent的初始化放在Application中build = DaggerAppComponent.builder().cModule(new CModule()).build(); MainActivity中的初始化 12345DaggerMainComponent.builder() .appComponent(App.build) .bModule(new BModule()) .build() .infect(this); 自定义的Scope 1234@Scope@Retention(RUNTIME)public @interface UserScope &#123;&#125; 包含方式 123456789101112131415@UserScope@Subcomponent(modules = BModule.class)public interface MainComponent &#123; void infect(MainActivity a);&#125;@Singleton@Component(modules = CModule.class)public interface AppComponent &#123; MainComponent m(BModule b);&#125;DaggerAppComponent.builder() .cModule(new CModule()) .build() .m(new BModule()) .infect(this); 继承方式这种方式比较复杂，需要Dagger2版本在2.7及以上，我在实现过程中总是出现一些奇怪的问题，在这里我只把Dependency Injection with Dagger 2中的代码贴上，等过段时间再回来研究 参考博客：Dependency Injection with Dagger 2浅析Dagger2的使用关于依赖注入框架dagger2的使用和理解Android：dagger2让你爱不释手-基础依赖注入框架篇Android：dagger2让你爱不释手-重点概念讲解、融合篇Android：dagger2让你爱不释手-终结篇]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Dagger2</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日/夜模式切换]]></title>
    <url>%2F2017%2F03%2F13%2F%E6%97%A5%E5%A4%9C%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[日/夜模式切换作为一个App的基本功能经常会被使用到，接下来就举出一些常用的日/夜模式切换的方法 使用UIMode的方法这种方式操作起来比较简单，就是将不同模式下的资源分开存放，然后调用方法切换资源即可 资源存放的路径 切换资源的方法 123456if (isNight) &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);&#125; else &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);&#125;recreate(); 其中AppCompatDelegate.MODE_NIGHT_YES代表切换到夜间模式，AppCompatDelegate.MODE_NIGHT_NO代表切换到日间模式如果是在新的Activity中切换日/夜模式则需要用RxBus(关于RxBus的用法可以参照我上篇博客)通知在后台的Activity调用recreate()重启Activity 最终效果 存在问题 由于需要recreate(),会重绘Activity导致屏幕闪烁，重新加载Avtivity时需要注意Activity内元素的保存 使用Theme通过切换不同的主题来实现切换日/夜模式的效果 在attrs.xml中设置主题中需要替换资源 12345&lt;resources&gt; &lt;attr name=&quot;bg&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;button_bg&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;button_tv&quot; format=&quot;color&quot;&gt;&lt;/attr&gt;&lt;/resources&gt; 设置日/夜模式主题 123456789101112131415 &lt;style name=&quot;Day&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;bg&quot;&gt;#FFFFFF&lt;/item&gt; &lt;item name=&quot;button_bg&quot;&gt;#A9A9A9&lt;/item&gt; &lt;item name=&quot;button_tv&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;Night&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;bg&quot;&gt;#4F4F4F&lt;/item&gt; &lt;item name=&quot;button_bg&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;button_tv&quot;&gt;#FFFFFF&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#828282&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#828282&lt;/item&gt;&lt;/style&gt; 在layout文件中使用arrts中的资源属性 1android:backgroundTint=&quot;?attr/button_bg&quot; 在Activity中切换主题 12345 if(isNight)&#123; setTheme(R.style.Night);&#125;else&#123; setTheme(R.style.Day);&#125; 设置主题需要放在setContentView()之前，所以每次切换完日/夜模式后都需要重新加载Activity 存在问题 与UIMode方法相同由于需要recreate(),会重绘Activity导致屏幕闪烁，并且在有比较多的属性需要修改时会导致style比较复杂 为了决解改变日/夜模式后屏幕闪烁的问题，我看了不少博客，终于找到了一个比较符合要求的项目，能够实现uiMode方法的不重建Activity切换日/夜模式。项目地址：https://github.com/geminiwen/SkinSprite 效果： 具体思路是在Activity创建View的过程中注入自己的代码。接下来分析一下这个lib的具体代码 首先是SkinnableActivity，继承自AppCompatActivity，在这个Activity中对View的创建进行拦截，我们主要关注三个方法 1)123456@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; LayoutInflater layoutInflater = LayoutInflater.from(this); LayoutInflaterCompat.setFactory(layoutInflater, this); super.onCreate(savedInstanceState);&#125; 注入自己的LayoutInflatorFactory，使inflate在这个LayoutInflaterFactory中执行 2) 12345678910111213@Overridepublic View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; if (mSkinnableViewInflater == null) &#123; mSkinnableViewInflater = new SkinnableViewInflater(); &#125; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mSkinnableViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ );&#125; 这是具体需要创建View的方法，可以看到他将具体的创建逻辑放到了SkinnableViewInflater中，这个类之后在做分析 3) 1234567891011121314public void setDayNightMode(@AppCompatDelegate.NightMode int nightMode) &#123; final boolean isPost21 = Build.VERSION.SDK_INT &gt;= 21; getDelegate().setLocalNightMode(nightMode); if (isPost21) &#123; applyDayNightForStatusBar(); applyDayNightForActionBar(); &#125; View decorView = getWindow().getDecorView(); applyDayNightForView(decorView);&#125; 这是一个我们之后需要切换日夜模式需要调用的方法，其中主要调用逻辑有1getDelegate().setLocalNightMode(nightMode); 对系统日/夜模式的资源进行切换 1234if (isPost21) &#123; applyDayNightForStatusBar(); applyDayNightForActionBar();&#125; 如果api等级大于等于21（即5.0及以上版本）则更换状态栏和标题栏资源1applyDayNightForView(decorView); 对于内容中的日/夜资源进行切换，这个方法我们可以看下他的具体实现 123456789101112131415private void applyDayNightForView(View view) &#123; if (view instanceof Skinnable) &#123; Skinnable skinnable = (Skinnable) view; if (skinnable.isSkinnable()) &#123; skinnable.applyDayNight(); &#125; &#125; if (view instanceof ViewGroup) &#123; ViewGroup parent = (ViewGroup)view; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; applyDayNightForView(parent.getChildAt(i)); &#125; &#125;&#125; 可以看到这是一个递归的方法，功能是遍历了view下所有的子view，对实现了Skinnable接口并且isSkinnable()返回true的view调用applyDayNight()。可以猜想到这些View就是自定义的View，这个applyDayNight()就是刷新View中资源的方法。 接下来可以看下上面的SkinnableViewInflater这个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public final View createView(View parent, final String name, @NonNull Context context,@NonNull AttributeSet attrs, boolean inheritContext,boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) &#123; final Context originalContext = context; // We can emulate Lollipop&apos;s android:theme attribute propagating down the view hierarchy // by using the parent&apos;s context if (inheritContext &amp;&amp; parent != null) &#123; context = parent.getContext(); &#125; if (readAndroidTheme || readAppTheme) &#123; // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); &#125; if (wrapContext) &#123; context = TintContextWrapper.wrap(context); &#125; View view = null; // We need to &apos;inject&apos; our tint aware Views in place of the standard framework versions switch (name) &#123; case &quot;TextView&quot;: view = new SkinnableTextView(context, attrs); break; case &quot;ImageView&quot;: view = new AppCompatImageView(context, attrs); break; case &quot;Button&quot;: view = new SkinnableButton(context, attrs); break; case &quot;EditText&quot;: view = new AppCompatEditText(context, attrs); break; case &quot;Spinner&quot;: view = new AppCompatSpinner(context, attrs); break; case &quot;ImageButton&quot;: view = new AppCompatImageButton(context, attrs); break; case &quot;CheckBox&quot;: view = new AppCompatCheckBox(context, attrs); break; case &quot;RadioButton&quot;: view = new AppCompatRadioButton(context, attrs); break; case &quot;CheckedTextView&quot;: view = new AppCompatCheckedTextView(context, attrs); break; case &quot;AutoCompleteTextView&quot;: view = new AppCompatAutoCompleteTextView(context, attrs); break; case &quot;MultiAutoCompleteTextView&quot;: view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case &quot;RatingBar&quot;: view = new AppCompatRatingBar(context, attrs); break; case &quot;SeekBar&quot;: view = new AppCompatSeekBar(context, attrs); break; case &quot;LinearLayout&quot;: view = new SkinnableLinearLayout(context, attrs); break; case &quot;FrameLayout&quot;: view = new SkinnableFrameLayout(context, attrs); break; case &quot;RelativeLayout&quot;: view = new SkinnableRelativeLayout(context, attrs); break; case &quot;android.support.v7.widget.Toolbar&quot;: view = new SkinnableToolbar(context, attrs); break; &#125; if (view == null &amp;&amp; originalContext != context) &#123; // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); &#125; if (view != null) &#123; // If we have created a view, check it&apos;s android:onClick checkOnClickListener(view, attrs); &#125; return view;&#125; 这个是SkinnableViewInflater中最主要的方法，根据name创建出不同的View，即自定义的View，这里并没有把所有的view都做出来，但是都大同小异，如果不够用还可以自己添加 最后只剩下View的没有看了，由于View比较多而且其中的内容都相似，我们拿SkinnableLinearLayout作为案例进行研究 123456789101112131415161718192021222324252627public SkinnableLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mAttrsHelper = new AttrsHelper(); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SkinnableView, defStyleAttr, 0); mAttrsHelper.storeAttributeResource(a, R.styleable.SkinnableView); a.recycle();&#125;@Overridepublic void applyDayNight() &#123; Context context = getContext(); int key; key = R.styleable.SkinnableView[R.styleable.SkinnableView_android_background]; int backgroundResource = mAttrsHelper.getAttributeResource(key); if (backgroundResource &gt; 0) &#123; Drawable background = ContextCompat.getDrawable(context, backgroundResource); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; setBackgroundDrawable(background); &#125; else &#123; setBackground(background); &#125; &#125;&#125; SkinnableLinearLayout中的思路也比较简单，在构造方法中向mAttrsHelper添加如属性，在需要刷新是再从mAttrsHelper中取出。对于不同的View也只是属性的内容不同而已 至此就是这个项目的大致源码，然后只需要将Activity继承SkinnableActivity,将uiMode中的AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);改为 setDayNightMode(AppCompatDelegate.MODE_NIGHT_YES); 并且不需要调用recreate()方法。需要注意的是还需要在该Activity中添加上android:configChanges=”uiMode”。 结语：这是我第一次写关于阅读源码的博客，尽管选了一个比较简单的lib但还是表达得比较凌乱。我之后还是会多多尝试写这方面的博客，努力提高自己的水平。 参考博客：android 实现【夜晚模式】的另外一种思路Android通过改变主题实现夜间模式Android实现日夜间模式的深入理解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RxJava的RxBus]]></title>
    <url>%2F2017%2F03%2F08%2F%E5%9F%BA%E4%BA%8ERxJava%E7%9A%84RxBus%2F</url>
    <content type="text"><![CDATA[RxBus是一个基于RxJava和RxAndroid的事件通讯工具 首先需要导入RxJava，RxAndroid库 12compile &apos;io.reactivex:rxandroid:1.2.1&apos;compile &apos;io.reactivex:rxjava:1.1.6&apos; RxBus基本代码 123456789101112131415161718192021222324252627public class RxBus &#123; private static volatile RxBus defaultInstance; private Subject&lt;Object,Object&gt; bus; public RxBus()&#123; bus=new SerializedSubject&lt;&gt;(PublishSubject.create()); &#125; //单例 public static RxBus getInstance()&#123; if(defaultInstance==null)&#123; synchronized(RxBus.class)&#123; if(defaultInstance==null)&#123; defaultInstance=new RxBus(); &#125; &#125; &#125; return defaultInstance; &#125; //发送一个事件 public void post(Object o)&#123; bus.onNext(o); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType)&#123; return bus.ofType(eventType); &#125;&#125; 使用 1. 发出事件 123Student s=new Student();s.setName(&quot;sss&quot;);RxBus.getInstance().post(s); 2.消费事件 123456789101112subscribe = RxBus.getInstance().toObservable(Student.class) //在io线程进行订阅，可以执行一些耗时操作 .subscribeOn(Schedulers.io()) //在主线程进行观察，可做UI更新操作 .observeOn(AndroidSchedulers.mainThread()) //观察的对象 .subscribe(new Action1&lt;Student&gt;() &#123; @Override public void call(Student s) &#123; Toast.makeText(MainActivity.this, s.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 3.在onDestory中移除订阅 1234567@Overrideprotected void onDestroy() &#123; super.onDestroy(); if(!subscribe.isUnsubscribed()) &#123; subscribe.unsubscribe(); &#125;&#125; 与EventBus相同RxBus也可以使用黏性事件修改过后的支持黏性事件的RxBus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class RxBus &#123; private static volatile RxBus defaultInstance; private final Map&lt;Class&lt;?&gt;,Object&gt; mStickyEventMap; private Subject&lt;Object,Object&gt; bus; public RxBus()&#123; bus=new SerializedSubject&lt;&gt;(PublishSubject.create()); mStickyEventMap=new ConcurrentHashMap&lt;&gt;(); &#125; //单例 public static RxBus getInstance()&#123; if(defaultInstance==null)&#123; synchronized(RxBus.class)&#123; if(defaultInstance==null)&#123; defaultInstance=new RxBus(); &#125; &#125; &#125; return defaultInstance; &#125; /** * 发送一个事件 * @param o */ public void post(Object o)&#123; bus.onNext(o); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType)&#123; return bus.ofType(eventType); &#125; //sticky事件 /** * 发送sticky事件 * @param event */ public void postSticky(Object event)&#123; synchronized (mStickyEventMap)&#123; mStickyEventMap.put(event.getClass(),event); &#125; post(event); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservableSticky(final Class&lt;T&gt; eventType)&#123; synchronized (mStickyEventMap)&#123; Observable&lt;T&gt; observable = bus.ofType(eventType); final Object event=mStickyEventMap.get(eventType); if(event!=null)&#123; return observable.mergeWith(Observable.create(new Observable.OnSubscribe&lt;T&gt;() &#123; @Override public void call(Subscriber&lt;? super T&gt; subscriber) &#123; subscriber.onNext(eventType.cast(event)); &#125; &#125;)); &#125;else&#123; return observable; &#125; &#125; &#125; /** * 获取sticky事件 * @param eventType * @param &lt;T&gt; * @return */ public &lt;T&gt; T getStickyEvent(Class&lt;T&gt; eventType)&#123; synchronized(mStickyEventMap)&#123; return eventType.cast(mStickyEventMap.get(eventType)); &#125; &#125; /** * 移除指定的sticky事件 * @param eventType * @param &lt;T&gt; * @return */ public &lt;T&gt; T removeStickyEvent(Class&lt;T&gt; eventType)&#123; synchronized (mStickyEventMap)&#123; return eventType.cast(mStickyEventMap.remove(eventType)); &#125; &#125; /** * 移除所有sticky事件 */ public void removeAllStickyEvents()&#123; synchronized (mStickyEventMap)&#123; mStickyEventMap.clear(); &#125; &#125;&#125; 要发送黏性事件需要使用postSticky()发送事件使用toObservableSticky接受事件，与其他使用与普通事件相同 由于黏性事件保存在RxBus中，当不需要使用时除了要subscribe.unsubscribe()取消订阅还需要RxBus.getInstance().removeStickyEvent(Class);移除粘性事件 关于RxJava中的异常当RxJava中发生异常时会调用onError方法，并且结束整个订阅事件，这会导致之后发出的事件不能接受的问题，需要用try…catch…捕捉异常 参考博客：用RxJava实现事件总线(Event Bus)[深入RxBus]：支持Sticky事件[深入RxBus]：异常处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>RxJava</tag>
        <tag>RxAndroid</tag>
        <tag>事件通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object的clone方法]]></title>
    <url>%2F2017%2F03%2F07%2FJava%20Object%E7%9A%84clone%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Object中有clone()方法protected Object clone() throws CloneNotSupportedException clone()的作用是创建一个该对象的一个副本，并将对象的数据复制到该副本中 根据复制程度的不同，clone可以分为：浅拷贝：使用clone()即为浅拷贝，默认的拷贝方式是复制一个新的原对象，并赋予原对象相同的全局对象的值和引用。即原对象和复制对象的全局引用变量指向的是一个相同的对象空间。深拷贝：需要自己实现，即将原对象中的全局引用变量指向的对象也复制一份放入复制对象中。 这两个概念可能不太好理解，可以根据下面的案例来加深理解。 首先明确对Object clone的要求 实现Cloneable接口，如果不实现该接口会在clone方法中抛出CloneNotSupportedException异常 需要重写clone方法，clone方法在Object中是protect的，不能被外部访问，需要重写并修改为public的访问权限。 运行类 1234567891011121314151617181920212223242526class Test&#123; @Test public void ttt() throws CloneNotSupportedException &#123; A a=new A(); B b=new B(); a.setName(&quot;one&quot;); a.setB(b); b.setAge(1); A ca= (A) a.clone(); a.setName(&quot;two&quot;); a.getB().setAge(2); System.out.print(&quot;a.name=&quot;+a.getName()+&quot;\n&quot;+ &quot;a.b.age=&quot;+a.getB().getAge()+&quot;\n&quot;+ &quot;ca.name=&quot;+ca.getName()+&quot;\n&quot;+ &quot;ca.b.age=&quot;+ca.getB().getAge()); //打印 /* a.name=two a.b.age=2 ca.name=one ca.b.age=2 */ &#125;&#125; 12345678910111213141516171819202122232425class A implements Cloneable&#123; private String name; private B b; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public B getB() &#123; return b; &#125; public void setB(B b) &#123; this.b = b; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 12345678910111213141516class B implements Cloneable&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 上面的案例即为浅拷贝，可以看到ca为a的拷贝对象，但是两个对象的b指向的是同一个B的对象。 进行深拷贝：需要修改A中的clone方法 123456789@Overridepublic Object clone() throws CloneNotSupportedException &#123; A o=null; o=(A)super.clone(); if(o.b!=null)&#123; o.b=(B)o.b.clone(); &#125; return o;&#125; 在test中的打印结果为： 1234a.name=twoa.b.age=2ca.name=oneca.b.age=1 另一种利用序列化来实现对象的深拷贝需要序列化，首先要让A和B都实现Serializable接口在A中添加深拷贝方法 12345678public Object deepClone() throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream bo=new ByteArrayOutputStream(); ObjectOutputStream oo=new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi=new ObjectInputStream(bi); return oi.readObject();&#125; 该方法先将可序列化对象a写入流中，再将对象从流中读出来重建对象 参考博客：java.lang.Object.clone()分析Java Object对象之clone方法Object的clone()方法、深拷贝、浅拷贝]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Object clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门]]></title>
    <url>%2F2016%2F11%2F24%2Fpython%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[python这几天闲的无聊想做一个爬虫来爬取一些‘正经’网站，首先选择用python作为爬虫的语言。但是没有接触过python怎么办呢，只能从头开始学了。python学习地址这个是廖大神写的一个python入门，个人感觉写的非常不错，在粗略的学习了一遍之后感觉可以开始我的爬虫之旅了。 静态网页爬虫目标：抓取http://tieba.baidu.com/p/2166231880中妹子的图片保存在本地接下来分析一下我们需要做的事 获取网页html代码 将html中的图片地址提取出来 根据图片地址获取图片内容 将图片保存在本地 话不多少，直接上代码1234567891011121314151617181920from urllib import requestfrom html.parser import HTMLParserimport osclass MyHtml(HTMLParser): path=os.path.join(os.path.abspath(&apos;.&apos;),&apos;pic&apos;) if not os.path.exists(path): os.mkdir(path) def handle_starttag(self,tag,attrs): if tag==&apos;img&apos; and attrs[0][0]==&apos;pic_type&apos; and attrs[0][1]==&apos;0&apos;: print(attrs[2][1]) with request.urlopen(attrs[2][1]) as picdate: with open(os.path.join(self.path,attrs[2][1][-10:]),&apos;wb&apos;) as fd: fd.write(picdate.read())with request.urlopen(&apos;http://tieba.baidu.com/p/2166231880&apos;) as f: if f.status==200: parser=MyHtml() parser.feed(f.read().decode(&apos;utf-8&apos;)) else: print (&apos;url error&apos;) 这一部分都比较简单，用urllib获取到页面信息后，通过HTMLParser对有用的信息进行提取，然后再使用urllib加载图片保存到本地 获取含有js的复杂网页通过上一个例子我们已经对爬虫的爬取过程有了一个初步的了解，接下来我们需要接受更大的世界了。目标:https://mm.taobao.com/search_tstar_model.htm?spm=719.1001036.1998606017.2.pA4hNo首先想到的是通过之前的经验，先获取html再从html中加载图片信息。但是通过查看网页的源码后就发现，原来网页上的那么多的妹子的图片居然一张也没有在源码中显示。看来原来爬取静态网页的方法已经不适用了，我们要使用其他的手段了。 分析出现上述结果是因为网页上的图片项都是通过js添加进去的，那么我们有两种方法来解决这个问题： 分析js代码，找出添加的内容 先让js运行，我们从js处理完毕的html中获取我们想要的信息 这里我们选择第二种方法，为了让js运行就需要一些工具selenium+PhantomJSselenium是一个自动化测试工具，可以同过 pip install selenium 来安装PhantomJS其实就是一个浏览器，只是它没有界面，我们的js就是依赖它来执行的。http://phantomjs.org/download.html从这个地址下载，把其中的phantomjs.exe文件放在python目录下（确保你的python目录已经在环境变量中配置好了） 还有一个非常实用的爬虫工具需要安装pip install beautifulsoup4，这个是用来提取html元素的。如果不是很了解可以参考这篇文章好了，准备工作都做好了，可以开工了 1234567891011121314151617181920212223242526272829303132333435363738394041424344from urllib import requestfrom bs4 import BeautifulSoupfrom selenium import webdriverimport osimport timeclass MyHtml(): def __init__(self): self.host=&apos;https://mm.taobao.com/search_tstar_model.htm?spm=719.1001036.1998606017.2.pA4hNo&apos; self.path=os.path.join(os.path.abspath(&apos;.&apos;),&apos;mm&apos;) if not os.path.exists(self.path): os.mkdir(self.path) self.browser=webdriver.PhantomJS() self.count=0 def start(self,n=False): if not n: print(self.host) self.browser.get(self.host) print(&apos;第&apos;+str(self.count)+&apos;项&apos;) self.soup=BeautifulSoup(self.browser.page_source) for li in self.soup.find_all(&apos;li&apos;,class_=&apos;item&apos;): self.img=li.find(&apos;img&apos;) if self.img.has_attr(&apos;data-ks-lazyload&apos;): self.src=&apos;https:&apos;+self.img[&apos;data-ks-lazyload&apos;] else: self.src=&apos;https:&apos;+self.img[&apos;src&apos;] print(self.src) self.name=str(li.find(&apos;span&apos;,class_=&apos;name&apos;).string) try: with request.urlopen(self.src) as pic: if pic.status==200: with open(os.path.join(self.path,self.name+&apos;.jpg&apos;),&apos;wb&apos;) as pici: pici.write(pic.read()) except BaseException: print(&apos;这个地址有问题&apos;) if self.count&lt;10:#数据太多这里只取前十项 self.browser.find_element_by_class_name(&apos;page-next&apos;).click() # time.sleep(3) self.start(True) self.count=self.count+1if &apos;__main__&apos;==__name__: MyHtml().start() 最后到这里我们已经知道了python爬虫的入门用法。但是我们发现这个爬虫的效率太低，这时可以用多线程提高爬虫效率。当同一个ip在一个网站访问频率太高时可能会出现验证码，这时需要做访问延迟和使用代理ip。爬虫路还很长，还有许多知识需要学习。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide图片加载]]></title>
    <url>%2F2016%2F10%2F26%2FGlide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Glide是一款bumptech发布，并被Google推荐使用的图片加载库。项目地址是https://github.com/bumptech/glide，本文不会对Glide的内存占用和性能进行分析，只是介绍Glide的基本用法。 导入库12compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;compile &apos;com.android.support:support-v4:19.1.0&apos; 基本操作12345Glide.with(context) //关联activity或fragment的生命周期 .load(url) //加载地址(url,资源id，本地图片file) .placeholder(id) //未加载时的占位图 .error(id) //加载失败时的占位图 .into(ImageView); //加载对象 基本配置Glide的配置是通过实现GlideModule接口来设置。 123456789public class MyGlideModule implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; &#125; @Override public void registerComponents(Context context, Glide glide) &#123; &#125;&#125; 然后需要在AndroidManifest.xml中声明 123&lt;meta-data android:name=&quot;com.shangbang.store.base.MyGlideModule&quot; android:value=&quot;GlideModule&quot; /&gt; 由于Glide是通过反射将GlideModule实例化得，所以需要在混淆文件中加入-keep public class * implements com.bumptech.glide.module.GlideModule 接下来介绍一些Glide的常用配置 配置图片本地缓存位置和本地缓存大小 123456789101112public void applyOptions(final Context context, GlideBuilder builder) &#123; builder.setDiskCache(new DiskCache.Factory() &#123; @Override public DiskCache build() &#123; //缓存的文件夹 File cacheLocation = new File(context.getExternalCacheDir(), &quot;glide&quot;); if (!cacheLocation.exists()) cacheLocation.mkdirs(); return DiskLruCacheWrapper.get(cacheLocation, 250 * 1024 * 1024);//本地缓存的大小 &#125; &#125;);&#125; 设置解码格式Glide默认的采用的使RGB_565，如果你对图片的质量要求较高可以采用ARGB_8888格式，缺点是ARGB_8888的内存占用是RGB_565的两倍。此外，ARGB_8888是支持透明格式的，而RGB_565不支持。 123 public void applyOptions(final Context context, GlideBuilder builder) &#123; builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);&#125; 特殊要求的使用 缓存策略 12345 .diskCacheStrategy(Type) //设置缓存到本地的策略DiskCacheStrategy.NONE //不会缓存到本地DiskCacheStrategy.SOURCE //只缓存原图DiskCacheStrategy.RESULT //只缓存最终图像（默认）DiskCacheStrategy.ALL //缓存所有图像 图片格式设置Glide中给了两种图片的放入格式，需要注意的是使用Glide的图片格式时就不要在ImageView中设置scaleType了，否则可能会使Glide的图片格式失效。 12.centerCrop() //自适应控件大小.fitCenter() //适应图片大小 加载优先级 12345 .priority(TYPE) //优先级由低到高Priority.LOWPriority.NORMALPriority.HIGHPriority.IMMEDIATE 缩略图 1234Glide.with(this) .load(&quot;http://my.csdn.net/uploads/201205/06/1336311585_2632.gif&quot;) .thumbnail(0.1f) .into(iv); 利用thumbnail(0.1f)来设置先加载0.1f的缩略图显示，然后再加载需要的图缩略图原图 自定义图片转化这里以制作圆形头像为例介绍.transform()的使用1234Glide.with(context) .load(url) .transform(new CircleTransform(context)) .into(imageView); 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CircleTransform extends BitmapTransformation &#123; public CircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool,toTransform); &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; int size = Math.min(source.getWidth(), source.getHeight()); int width = (source.getWidth() - size) / 2; int height = (source.getHeight() - size) / 2; Bitmap bitmap = pool.get(size, size, Bitmap.Config.ARGB_8888); if (bitmap == null) &#123; bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); BitmapShader shader = new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP); if (width != 0 || height != 0) &#123; // source isn&apos;t square, move viewport to center Matrix matrix = new Matrix(); matrix.setTranslate(-width, -height); shader.setLocalMatrix(matrix); &#125; paint.setShader(shader); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return bitmap; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 回调bitmap 123456private SimpleTarget target = new SimpleTarget&lt;Bitmap&gt;( 250, 250 ) &#123; //250,250可不加，表示原图大小 @Override public void onResourceReady(Bitmap bitmap, GlideAnimation glideAnimation) &#123; imageView2.setImageBitmap( bitmap ); &#125; &#125;; 12345Glide .with( context.getApplicationContext() ) // safer! .load( url ) .asBitmap() .into( target ); 利用这种方法可以直接获得bitmap，然后可以根据需要对Bitmap进行处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>图片加载</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP模式]]></title>
    <url>%2F2016%2F09%2F23%2FMVP%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言MVP是一种MVC的变形，相比MVC它大大减少了Activity的责任将主要的逻辑操作集中在Presenter层中，从而使得MVP的代码结构变得更清晰。 MVP结构MVP主要由Model、View、Presenter三部分构成。Model:负责数据的处理，即数据的获取、存储、解析、分发、修改等操作；View:即Activity和Fragment，负责页面的绘制，刷新；Presenter:负责连接Model层和View层，从Model中获取数据然后控制View刷新页面，是主要逻辑操作的地方。 这里借用此文的一张图片来表示Model、View和Presenter三者的关系 MVP案例这是一个简单的菜谱App，主要包括列表和详情，下面以列表页威力展示一下MVP的运用。 列表页视图: 项目结构: (1)Model层这里的Model主要负责从网络获取数据123456789public interface ITypeListModel &#123; void loadList(String url, Map&lt;String,String&gt; paraMap, TypeListListener listener); void cancle(); interface TypeListListener&#123; void loadSuccess(String json,Map&lt;String,String&gt; hMap); void loadFail(Exception e,Map&lt;String,String&gt; hMap); &#125;&#125; 1234567891011121314151617181920212223242526272829public class TypeListModel implements ITypeListModel &#123; private RequestCall call; @Override public void loadList(String url, final Map&lt;String, String&gt; paraMap, final ITypeListModel.TypeListListener listener) &#123; call= OkHttpUtils.post() .url(url) .params(paraMap) .build(); call.execute(new StringCallback() &#123; @Override public void onError(Call call, Exception e, int id) &#123; listener.loadFail(e,paraMap); &#125; @Override public void onResponse(String response, int id) &#123; listener.loadSuccess(response,paraMap); &#125; &#125;); &#125; @Override public void cancle() &#123; if(call!=null) call.cancel(); &#125;&#125; (2)View层View层管理点击页面上控件的状态和控件的点击事件我将View和Presenter的两个接口都放在了Contract中方便管理 12345678910111213141516171819interface View&#123; void showLoading(); void hideLoading(); void showLoadFail(); void hideLoadFail(); void showContent(); void hideContent(); void toastMessage(String message); void setContentData(List&lt;FoodTypeGroup&gt; list);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class FoodTypeActivity extends AppCompatActivity implements FoodTypeContract.View, View.OnClickListener, ExpandableListView.OnChildClickListener &#123; @Bind(R.id.tv_head_back) View tvBack; @Bind(R.id.tv_head_title) TextView tvTitle; @Bind(R.id.elv_content) ExpandableListView elvContent; @Bind(R.id.progressBar) View progressBar; @Bind(R.id.tv_fail) View tvFail; private FoodTypeAdapter adapter; private List&lt;FoodTypeGroup&gt; adapterList; private FoodTypeContract.Presenter foodTypePresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_food_type); ButterKnife.bind(this); foodTypePresenter=new FoodTypePresenter(this); initView(); initAdapter(); foodTypePresenter.start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); foodTypePresenter.onDestroy(); &#125; private void initView() &#123; tvBack.setVisibility(View.GONE); tvTitle.setText(&quot;菜品分类&quot;); tvFail.setOnClickListener(this); elvContent.setOnChildClickListener(this); &#125; private void initAdapter()&#123; adapterList=new ArrayList&lt;&gt;(); adapter=new FoodTypeAdapter(this,adapterList); elvContent.setAdapter(adapter); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.tv_fail://重新加载 foodTypePresenter.start(); break; &#125; &#125; @Override public boolean onChildClick(ExpandableListView expandableListView, View view, int i, int i1, long l) &#123; Intent intent=new Intent(this,TypeListActivity.class); intent.putExtra(&quot;id&quot;,adapterList.get(i).getList().get(i1).getId()); intent.putExtra(&quot;type&quot;,adapterList.get(i).getList().get(i1).getName()); startActivity(intent); return true; &#125; @Override public void showLoading() &#123; progressBar.setVisibility(View.VISIBLE); &#125; @Override public void hideLoading() &#123; progressBar.setVisibility(View.GONE); &#125; @Override public void showLoadFail() &#123; tvFail.setVisibility(View.VISIBLE); &#125; @Override public void hideLoadFail() &#123; tvFail.setVisibility(View.GONE); &#125; @Override public void showContent() &#123; elvContent.setVisibility(View.VISIBLE); &#125; @Override public void hideContent() &#123; elvContent.setVisibility(View.GONE); &#125; @Override public void toastMessage(String message)&#123; ToastUtil.showToast(this,message); &#125; @Override public void setContentData(List&lt;FoodTypeGroup&gt; list) &#123; adapterList.clear(); adapterList.addAll(list); adapter.notifyDataSetChanged(); &#125;&#125; (3)Presenter层从View中接收到获取列表请求后调用Model获取列表数据，根据列表数据的状态控制View作不同的显示 1234567interface Presenter extends BasePresenter&#123; @Override void start(); @Override void onDestroy();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class FoodTypePresenter implements FoodTypeContract.Presenter&#123; private FoodTypeContract.View foodTypeView; private IFoodTypeModel iFoodTypeModel; public FoodTypePresenter(FoodTypeContract.View foodTypeView)&#123; this.foodTypeView=foodTypeView; iFoodTypeModel=new FoodTypeModel(); &#125; @Override public void start() &#123; foodTypeView.hideContent(); foodTypeView.hideLoadFail(); foodTypeView.showLoading(); final Map&lt;String,String&gt; paraMap=new HashMap&lt;&gt;(); paraMap.put(&quot;key&quot;,BaseUrl.KEY); iFoodTypeModel.loadList(BaseUrl.FOODTYPE, paraMap, new IFoodTypeModel.FoodTypeListener() &#123; @Override public void loadSuccess(String json) &#123; LoadSuccess.onSuccess(json, new LoadSuccess.LoadSuccessCallBack() &#123; @Override public void code200(JSONObject json) throws JSONException &#123; if(foodTypeView!=null) &#123; List&lt;FoodTypeGroup&gt; list = JSON.parseArray(json.getJSONArray(&quot;result&quot;).toString(), FoodTypeGroup.class); foodTypeView.hideLoading(); foodTypeView.showContent(); foodTypeView.setContentData(list); &#125; &#125; @Override public void codeOther(String errorMessage) &#123; if(foodTypeView!=null) &#123; foodTypeView.hideLoading(); foodTypeView.showLoadFail(); foodTypeView.toastMessage(errorMessage); &#125; &#125; &#125;); &#125; @Override public void loadFail(Exception e) &#123; L.e(&quot;NET&quot;,e.getMessage()); if (foodTypeView!=null) &#123; foodTypeView.hideLoading(); foodTypeView.showLoadFail(); foodTypeView.toastMessage(&quot;网络连接异常&quot;); &#125; &#125; &#125;); &#125; @Override public void onDestroy()&#123; iFoodTypeModel.cancle(); foodTypeView=null; &#125;&#125; 项目地址https://github.com/NevLight/Fish]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar的使用]]></title>
    <url>%2F2016%2F09%2F21%2FToolbar%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在Android Studio中默认工程继承AppCompatActivity而不是Activity。从AppCompatActivity的源码中可以看到，它是继承自FragmentActivity的而它的另一个作用是代替了过时的ActionBarActivity，即用Toolbar代替ActionBar。接下来就介绍一下Toolbar的使用。 导入依赖包compile ‘com.android.support:appcompat-v7:24.1.1’ xml中设置12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/tool&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 在Activity中设置Toolbar基本设置1.设置标题12setTitle(&quot;title&quot;);setSupportActionBar(toolbar); 默认标题是靠右对齐，如果要居中或对标题样式有特殊需求可以在xml中的Toolbar标签中加入并配置其属性2.设置返回按钮1234567tool.setNavigationIcon(R.mipmap.back); tool.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(getWindow().getDecorView(),&quot;back&quot;,Snackbar.LENGTH_SHORT).show(); &#125; &#125;); 3.设置logo1tool.setLogo(R.mipmap.logo); 4.设置副标题1tool.setSubtitle(&quot;subtitle&quot;); 设置完以上参数的样式如下 menu设置1.menu基本设置在代码中设置获取menu1234567891011@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.food_type_menu,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; //各个item点击事件 return true; &#125; 在menu中设置menu样式1234567891011121314151617 &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &gt; &lt;item android:id=&quot;@+id/menu_group&quot; android:title=&quot;item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; app:showAsAction=&quot;always&quot; /&gt; &lt;item android:id=&quot;@+id/menu_clear&quot; android:title=&quot;item1&quot; app:showAsAction=&quot;never&quot; /&gt; &lt;item android:id=&quot;@+id/menu_refresh&quot; android:title=&quot;item2&quot; app:showAsAction=&quot;never&quot; /&gt;&lt;/menu&gt; 其中showAsAction属性共有五个值：ifRoom、never、always、withText、collapseActionView，可以混合使用。ifRoom 会显示在Item中，但是如果已经有4个或者4个以上的Item时会隐藏在溢出列表中。当然个数并不仅仅局限于4个，依据屏幕的宽窄而定never 永远不会显示。只会在溢出列表中显示，而且只显示标题，所以在定义item的时候，最好把标题都带上。always 无论是否溢出，总会显示。withText withText值示意Action bar要显示文本标题。Action bar会尽可能的显示这个标题，但是，如果图标有效并且受到Action bar空间的限制，文本标题有可能显示不全。collapseActionView 声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，并且即便在用于不适用的时候，也要占据操作栏的有效空间。一般要配合ifRoom一起使用才会有效果。 最终效果 2.menu样式默认的样式是白底黑字，可以通过设置Toolbar中的theme来改变样式1234&lt;!--&lt;style name=&quot;MenuStyle&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt;--&gt;&lt;style name=&quot;MenuStyle&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#ffffff&lt;/item&gt;&lt;/style&gt; 以上两个parent，ThemeOverlay.AppCompat.Light为白色背景ThemeOverlay.AppCompat.Dark.ActionBar为黑色背景，android:textColorPrimary设置字体颜色3.PopupMenuPopupMenu是一个轻量话的控件，与PopupWindow相比少了很多自定义的属性，这里我将PopupWindow作为一个Menu的展开来使用1234567891011121314151617PopupMenu popup=new PopupMenu(this,findViewById(R.id.menu_group));popup.getMenuInflater().inflate(R.menu.food_type_menu_item,popup.getMenu());popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; switch (item.getItemId())&#123; case R.id.item1: ToastUtil.showToast(FoodTypeActivity.this,&quot;item1&quot;); break; case R.id.item2: ToastUtil.showToast(FoodTypeActivity.this,&quot;item2&quot;); break; &#125; return true; &#125;&#125;);popup.show(); 如果需要改变PopupMenu的字体颜色和背景颜色就需要在该window对应的Activity中改变它的style1234&lt;style name=&quot;PpupmenuStyle&quot; parent=&quot;@style/AppTheme&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#ffffff&lt;/item&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt;&lt;/style&gt; 在AndroidManifest中设置style1&lt;activity android:name=&quot;.view.FoodTypeActivity&quot; android:theme=&quot;@style/PpupmenuStyle&quot;/&gt; 默认PopupMenu是只显示title不显示icon的，可以自己重写PopupMenu并修改相关属性来使之显示icon12345678try &#123; Field field = popup.getClass().getDeclaredField(&quot;mPopup&quot;); field.setAccessible(true); MenuPopupHelper mHelper = (MenuPopupHelper) field.get(popup); mHelper.setForceShowIcon(true);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 结尾以上就是关于Toolbar的一些东西，虽然常用的都是自定义的title，但还是有必要了解一下官方给的方案。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava的简单使用]]></title>
    <url>%2F2016%2F09%2F09%2FRxJava%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[为什么要用RxJava最近发现越来越多的项目开始使用RxJava，那么他到底有什么优势呢。总结来说有两点：1.代码简洁、逻辑清晰，避免了处理复杂逻辑时的大量代码嵌套2.线程自由控制，能够多次自由地切换线程，满足复杂异步操作的需求 RxJava的使用RxJava的主要组成是两个核心类Observables(被观察者、事件源)，Subscribers(观察者),实现完核心类后用subscribe()将两着订阅起来要使用RxJava首先引入两个依赖compile ‘io.reactivex:rxandroid:1.2.1’compile ‘io.reactivex:rxjava:1.1.6’接下来贴出几个小例子来简单演示RxJava的使用最基础的使用123456789101112131415161718192021222324252627//创建事件源 Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); &#125; &#125; );//创建观察者 Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Toast.makeText(SecondActivity.this, s ,Toast.LENGTH_SHORT).show(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;;//订阅 myObservable.subscribe(mySubscriber); 简化写法1234567891011121314151617181920212223Observable&lt;String&gt; myObservable = Observable.just(&quot;hellow simple&quot;);Action1&lt;String&gt; onNextAction=new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Toast.makeText(SecondActivity.this, s, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,s); &#125;&#125;;Action1&lt;Throwable&gt; onError=new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Toast.makeText(SecondActivity.this, &quot;error&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,&quot;error&quot;); &#125;&#125;;Action0 onCompleted=new Action0() &#123; @Override public void call() &#123; Toast.makeText(SecondActivity.this, &quot;completed&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,&quot;completed&quot;); &#125;&#125;;myObservable.subscribe(onNextAction,onError,onCompleted); RxJava还提供了简化写法，Observable.just()可以有多个Object参数，相当于实现了多次onNext(Object o)和一次onCompleted()。 操作符的使用大量的操作符是RxJava实现逻辑清晰的关键，他能将复杂的逻辑操作分散开来，使每一步的结果都清晰可见。接下来介绍几个常用的操作符 map对于事件作进一步处理,用于一对一的转化123456789101112131415Observable&lt;String&gt; myObservable = Observable.just(&quot;hellow simple&quot;); Observable&lt;String&gt; myObservableMap=myObservable.map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s+&quot;-xu&quot;; &#125; &#125;); Action1&lt;String&gt; onNextAction=new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Toast.makeText(SecondActivity.this, s, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,s); &#125; &#125;; myObservableMap.subscribe(onNextAction); fromfrom标签相当于调用了多次onNext(Object o)一次onCompleted()12345678910111213141516171819from标签相当于调用了多次onNext(Object o)一次onCompleted() String[] words = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; Observable&lt;String&gt; observable = Observable.from(words); observable.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(&quot;form&quot;, s); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i(&quot;from&quot;, &quot;error&quot;); &#125; &#125;, new Action0() &#123; @Override public void call() &#123; Log.i(&quot;from&quot;,&quot;complete&quot;); &#125; &#125;); flatMap与map不同的flatMap是用于一对多的转化12345678910111213141516List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); Observable&lt;List&lt;String&gt;&gt; observable=Observable.just(list); observable.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(List&lt;String&gt; strings) &#123; return Observable.from(strings); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(&quot;tag&quot;,s); &#125; &#125;); 线程控制几种线程的位置: Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行 变化线程操纵subscribeOn(Scheduler.io());事件产生的线程,作用在Observable.just(1, 2, 3, 4)，即Observable生成时，位置放在哪都可以，但只能调用一次observeOn(AndroidSchedulers.mainThread());事件消费的线程,用于Observable生成后的操作，可以多次调用实现线程的多次切换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable&lt;String&gt; observable=Observable.just(&quot;thread&quot;);observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map1___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).observeOn(Schedulers.io()).map(new Func1&lt;String,String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map2___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).map(new Func1&lt;String,String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map3___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;, Thread.currentThread().getId() + &quot;main___&quot;+System.currentTimeMillis()); &#125;&#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i(&quot;thread&quot;,&quot;wrong0&quot;); &#125;&#125;); 关于RxJava的功能还有很多我还未使用到，如果想要对RxJava有更多的了解可以参考以下几篇文章给 Android 开发者的 RxJava 详解深入浅出RxJavaAwesome-RxJava]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于键盘的一切]]></title>
    <url>%2F2016%2F09%2F09%2F%E5%85%B3%E4%BA%8E%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[1.windowSoftInputMode设置windowSoftInputMode的参数分为两种 限定进入Activity时键盘的状态(弹出还是隐藏) stateUnspecified：未指定的默认状态 stateUnchanged ：不改变键盘的状态——与上一个界面的键盘状态相同 stateHidden ：隐藏键盘 stateAlwaysHidden：隐藏键盘——进入下一个界面后返回还是隐藏键盘 stateVisible ：显示键盘 stateAlwaysVisible：显示键盘——进入下一个界面后返回还是显示键盘 设置键盘弹出时页面布局的改变的状态 adjustUnspecified：未指定的默认状态，自动适配屏幕 adjustResize ：Activity的主窗口总是会被调整大小，从而保证软键盘显示空间，键盘作为布局的一部分来展示 adjustPan ：利用布局移动来保证输入框在视野范围内 2.动态显示/隐藏键盘显示键盘 1234editText.setFocusableInTouchMode(true);editText.requestFocus();InputMethodManager inputManager =(InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);inputManager.showSoftInput(editText, 0); 隐藏键盘 12InputMethodManager inputManager =(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);inputManager.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); 3.键盘高度的监听当系统提供的adjustResize和adjustPan 不能满足页面布局设计的需求时可以通过监听键盘高度来动态改变布局123456789101112final View decorView= getWindow().getDecorView(); decorView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect=new Rect(); decorView.getWindowVisibleDisplayFrame(rect); int displayHeight=rect.bottom; int height=decorView.getHeight(); int keyboardHeight=height-displayHeight; Log.i("KEYBOARD","键盘的高度是"+keyboardHeight); &#125;&#125;); 4.改变键盘回车键显示和功能有时候需要改变键盘回车键来实现搜索、发送、完成等功能。12345678910111213141516171819// et.setImeOptions(EditorInfo.IME_ACTION_DONE);//完成// et.setImeOptions(EditorInfo.IME_ACTION_SEND);//发送// et.setImeOptions(EditorInfo.IME_ACTION_SEARCH);//搜索// et.setImeOptions(EditorInfo.IME_ACTION_GO);//前往// et.setImeOptions(EditorInfo.IME_ACTION_NEXT);//下一项// et.setImeOptions(EditorInfo.IME_ACTION_NONE);//默认// et.setImeOptions(EditorInfo.IME_ACTION_PREVIOUS);//上一项 et.setImeOptions(EditorInfo.IME_ACTION_UNSPECIFIED);//未指明 et.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View view, int i, KeyEvent keyEvent) &#123; if(i == KeyEvent.KEYCODE_ENTER &amp;&amp; keyEvent.getAction() == KeyEvent.ACTION_UP)&#123; Toast.makeText(MainActivity.this, &quot;按下了回车键&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; return false; &#125; &#125;); &#125; 最后，改变键盘回车键必须是singleLine的EditText才能实现]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText基础属性]]></title>
    <url>%2F2016%2F09%2F09%2FEditText%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.限制输入字符的长度(1)在xml中设置12&lt;EditText android:maxLines=&quot;11&quot;/&gt; (2)在代码中设置1editText.setFilters(new InputFilter[]&#123;new InputFilter.LengthFilter(11)&#125;); (3)对超出的长度给出提示1234567891011121314151617181920editText.addTextChangedListener(new TextWatcher() &#123; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; if(s.length()&gt;11)&#123; Toast.makeText(context, &quot;长度超出限制&quot;, Toast.LENGTH_LONG); editText.setText(s.subSequence(0, s.length()-1)); editText.setSelection(editText.getText().length()); &#125; &#125; &#125;); 2.输入类型的限制(1)限制只能输入指定类型1android:digits=&quot;0123456789xyzXYZ&quot; (2)特殊输入内容的限制1android:inputType=&quot;text&quot; 其中intputType的属性有 android:inputType=”textCapCharacters” 字母大写 android:inputType=”textCapWords” 首字母大写 android:inputType=”textCapSentences” 仅第一个字母大写 android:inputType=”textAutoCorrect” 自动完成 android:inputType=”textAutoComplete” 自动完成 android:inputType=”textMultiLine” 多行输入 android:inputType=”textImeMultiLine” 输入法多行（如果支持） android:inputType=”textNoSuggestions” 不提示 android:inputType=”textUri” 网址 android:inputType=”textEmailAddress” 电子邮件地址 android:inputType=”textEmailSubject” 邮件主题 android:inputType=”textShortMessage” 短讯 android:inputType=”textLongMessage” 长信息 android:inputType=”textPersonName” 人名 android:inputType=”textPostalAddress” 地址 android:inputType=”textPassword” 密码 android:inputType=”textVisiblePassword” 可见密码 android:inputType=”textWebEditText” 作为网页表单的文本 android:inputType=”textFilter” 文本筛选过滤 android:inputType=”textPhonetic” 拼音输入 android:inputType=”number” 数字 android:inputType=”numberSigned” 带符号数字格式 android:inputType=”numberDecimal” 带小数点的浮点格式 android:inputType=”phone” 拨号键盘 android:inputType=”datetime” 时间日期 android:inputType=”date” 日期键盘 android:inputType=”time” 时间键盘]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>EditText</tag>
      </tags>
  </entry>
</search>
