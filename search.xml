<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java内存回收]]></title>
    <url>%2F2019%2F08%2F18%2FJava%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[Java内存区域方法区、元空间各个线程共享的内存区域，用于储蓄已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区有时也被称为永久代。在 JDK1.8 及之后取消了永久代，取而代之的是元空间。在永久代中做调优是十分困难的，且效果不明显。永久代的空间大小受制于 JVM 本身内存限制，而元空间是直接使用机器的内存，只受系统内存限制。元空间默认最大大小为无限制。一些参数：12345-XX:PermSize=N //方法区初始大小-XX:MaxPermSize=N //方法区的最大大小-XX:MetaspaceSize=N //元空间的初始大小-XX:MaxMetaspaceSize=N //原空间的最大大小 堆堆是 Java 虚拟机所管理的内存中最大的一块，是所有线程所共享的，此内存区域的唯一目的就是存放对象实例。堆是垃圾收集器管理的主要区域。在 HotSpot 中，大多数情况下内存被分为新生代和老年代，默认分配比例为 1:2。在新生代中又被分为一个 Eden 和两个 Survivor ，分配比例为 8:1:1。新生代中对象的年龄在经历一次 Minor GC 后年龄会+1，当年龄达到15（默认值）后会进入老年代。一些参数：123456-XX:InitialHeapSize=N //堆初始大小-Xms1024m //简写值-XX:MaxHeapSize=N //堆的最大值-Xmx1024m //简写值-XX:MaxTenuringThreshold=15 //新生代进入老年代的年龄 栈区线程私有，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。包含程序计数器、虚拟机栈和本地方法栈。 垃圾收集算法哪些对象需要回收？ 引用计数算法给对象一个引用计数器，每当有一个地方引用它时，计数器就加 1，当引用失效时就减 1。任何计数器为 0 的对象都是不被使用的对象。缺点：难以解决循环引用问题。 可达性分析算法通过一系列的“GC Roots”作为起点，从这些节点开始向下搜索，搜索所达到的路径称为引用链。当一个对象不在任何引用链中，则此对象是不被使用的对象。 什么时候回收？在 可达性分析算法 中从 GC Roots 搜索时，必须保证引用的一致性，以使对象的引用关系不再发生变化。这点就导致了 GC 必须停止所有的执行线程（Stop The World）。在 HotSpot 中使用 OopMap 来记录调用信息。在代码中有 OopMap 记录的地方称为 SafePoint。当 GC 发生时，需要让所有线程先跑到 SafePoint 再执行 GC 操作。 如何回收？ 标记-清除算法同名字一样，这个方式分为“标记”和“清除”两个阶段，首先对不被使用的对象添加一个标记，之后对所有标记到的对象进行统一回收。缺点： 标记和清除两个阶段的效率都不高 在回收之后会产生大量不连续的内存碎片，导致以后难以储存较大的对象 复制算法将对象分为两块，当一块对象用完了，就将还在使用的对象复制到另一块对象上去。较 标记-清除算法 有更高的效率缺点：每次只能使用一块内存，使内存的利用率变低了。 标记-整理算法前半部分和 标记-清除算法 一样，但后续将所有存活的对象移向一端，清除了内存碎片。 分代收集算法根据对象的不同存活周期，一般把对象分为新生代和老年代，根据各个年代的特点采用不同的收集算法。对于新生代，每次都有大量对象死去，故采用复制算法。对于老年代，对象存活率高，采用 标记-清除 或 标记-整理 算法。 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 Serial一个最基本、发展历史最悠久的收集器。采用单线程的收集方式，且在收集时必须暂停其他所有的工作线程，直到收集结束。在 Client 模式下有较好效果。 ParNewParNew 收集器就是 Serial 的多线程版本，能与 CMS 配合工作。 Parallel Scavenge吞吐量优先的收集器。（吞吐量=用户代码运行时间/（用户代码运行时间+垃圾收集时间）） Serial OldSerial 的老年代版本 Parallel OldParallel Scavenge 的老年代版本，JDK1.7、JDK1.8 中以 Parallel Scavenge + Parallel Old 为默认的新生代、老年代回收器。 CMS以最短回收停顿时间为目的，对 CPU 资源敏感 G1JDK1.9 中的默认垃圾收集器，G1 的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量。G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。 内存分配策略在 HotSpot 中，大多数情况下内存被分为新生代和老年代，默认分配比例为 1:2。在新生代中又被分为一个 Eden 和两个 Survivor ，分配比例为 8:1:1。一个新的对象一般会在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，将发起一次 Minor GC。对于大对象(大量连续内存空间的Java对象)，会直接进入老年代。长期存活的对象(默认熬过 15 次 Minor GC)，会进入老年代。如果在 Survivor 中相同年龄的对象超过了 Survivor 的一般，这些对象将会直接进入老年代。 JDK命令行一些用于监视虚拟机状态和故障处理的命令 命令 作用 jps 显示系统内所有虚拟机进程 jstat 用于收集虚拟机各方面运行数据 jinfo 显示虚拟机配置信息 jmap 生成虚拟机内存转储快照（heapdump文件） jhat 用于分析 heapdump 文件 jstack 显示虚拟机线程快照]]></content>
      <categories>
        <category>大后台</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 识别文件编码]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[需求现有一个功能是用户上传一个 csv 文件到服务端。由于不想强制规定用户使用特定编码格式的文件（这样显得用户体验差），现需要能识别用户文件的编码格式来进行正确解码。这里只做 utf-8 和 gbk 的区分。 读取BOM首先什么是BOM。 字节顺序标记（英语：byte-order mark，BOM）是位于码点U+FEFF的统一码字符的名称。当以UTF-16或UTF-32来将UCS/统一码字符所组成的字符串编码时，这个字符被用来标示其字节序。它常被用来当做标示文件是以UTF-8、UTF-16或UTF-32编码的标记。——维基百科 简单来说就是在文件的开头会有几个特殊的字符来表明当前文件的编码格式，具体字符如图： 对于有 BOM 的文件可以先根据 BOM 来识别文件的编码格式。1234567891011121314public static String checkEncode(BufferedInputStream bis) throws IOException &#123; bis.mark(0); String encodeType; byte[] head = new byte[3]; bis.read(head); //FE FF if (head[0] == -1 &amp;&amp; head[1] == -2) &#123; encodeType = UTF16; //EF BB BF &#125; else if (head[0] == -17 &amp;&amp; head[1] == -69 &amp;&amp; head[2] == -65) &#123; encodeType = UTF8; &#125; return encodeType;&#125; 查看字节规则对于没有 BOM 的文件，需要根据 utf8 和 gbk 的编码规则不同来区别。根据 utf8 的编码规则逐字节判断是否符合编码规范。如果都符合则确定文件为 utf8 编码，否则为 gbk 编码。utf8 是一个字符由 1～4 个字节组成。一个字符的第一个字节标示了这个字符的字节个数，之后跟随的字节每一个都是10开头。具体如图结合 BOM 和 编码判断的完成代码如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.io.BufferedInputStream;import java.io.IOException;import java.io.InputStream;/** * 检查编码格式 */public class CheckEncodeUtil &#123; private static String UTF16 = "utf16"; private static String UTF8 = "utf8"; private static String GBK = "gbk"; /** * 检查输入流的编码格式(utf8 gbk) * * @param bis 需要是可reset的输入流 * @return */ public static String checkEncode(BufferedInputStream bis) throws IOException &#123; bis.mark(0); String encodeType; byte[] head = new byte[3]; bis.read(head); //FE FF if (head[0] == -1 &amp;&amp; head[1] == -2) &#123; encodeType = UTF16; //EF BB BF &#125; else if (head[0] == -17 &amp;&amp; head[1] == -69 &amp;&amp; head[2] == -65) &#123; //带BOM encodeType = UTF8; &#125; else if (isUTF8(bis)) &#123; encodeType = UTF8; &#125; else &#123; encodeType = GBK; &#125; bis.reset(); return encodeType; &#125; /** * 检查是否符合 utf8 的编码格式 * * @param is * @return */ private static boolean isUTF8(InputStream is) throws IOException &#123; is.reset(); int code; while ((code = is.read()) != -1) &#123; int count = getBtyeCount(code); if(count==0)&#123; return false; &#125;else if(count &gt; 1)&#123; if(!checkFollowByte(is, count))&#123; return false; &#125; &#125; &#125; return true; &#125; /** * 获取每个字符所占字节数count * * @param code * @return */ private static int getBtyeCount(int code) &#123; int state = code &amp; 0b11111 &lt;&lt; 3; if (state &gt; 0b1111 &lt;&lt; 4) &#123; return 0; &#125; if (state == 0b1111 &lt;&lt; 4) &#123; return 4; &#125; if (state &gt;= 0b111 &lt;&lt; 5) &#123; return 3; &#125; if (state &gt;= 0b11 &lt;&lt; 6) &#123; return 2; &#125; state = code &amp; 0b1 &lt;&lt; 7; if (state == 0) &#123; return 1; &#125; return 0; &#125; /** * 检查接下来的字节是否符合 utf8 规范 10xx xxxx * @param is * @param count * @return */ private static boolean checkFollowByte(InputStream is, int count) throws IOException&#123; byte[] bytes = new byte[count - 1];//已经读取了一个字节，不能再读取 is.read(bytes); for (byte b : bytes) &#123; if (!((b &amp; 0b11&lt;&lt;6) == 0b10&lt;&lt;6)) &#123; return false; &#125; &#125; return true; &#125;&#125; 关于 reset 的问题在 SpringMVC 中文件上传使用的是 MultipartFile 。从 MultipartFile 中得到的 InputStream 不支持 reset 的方法，会出现 IOException 。这里解决的方法是每次都从 MultipartFile 中获取 InputStream ，而在 CheckEncodeUtil 用完的 Stream 直接关掉。部分修改如下12345678910111213141516171819202122public static String checkEncode(BufferedInputStream bis) throws IOException &#123; String encodeType; try &#123; bis.mark(0); byte[] head = new byte[3]; bis.read(head); //FE FF if (head[0] == -1 &amp;&amp; head[1] == -2) &#123; encodeType = UTF16; //EF BB BF &#125; else if (head[0] == -17 &amp;&amp; head[1] == -69 &amp;&amp; head[2] == -65) &#123; encodeType = UTF8; &#125; else if (isUTF8(bis)) &#123; encodeType = UTF8; &#125; else &#123; encodeType = GBK; &#125; &#125;finally &#123; bis.close(); &#125; return encodeType;&#125;]]></content>
      <categories>
        <category>大后台</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码</tag>
        <tag>UTF8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose]]></title>
    <url>%2F2019%2F08%2F11%2Fdocker-compose%2F</url>
    <content type="text"><![CDATA[Docker Compose是什么Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它是在 Docker 的基础上轻松、高效地管理容器。 安装Docker Compose 的下载安装非常简单。在地址下载后12mv docker-compose /usr/bin/chmod +x /usr/bin/docker-compose docker-compose.ymldocker-compose.yml 是一个启动的配置文件。1234567891011121314151617181920212223242526version: '3'services: web: image: "java:latest" ports: - "80:8080" links: - java java: image: "work_app:latest" volumes: - "/root/docker/:/tmp" command: ["java","-jar","/tmp/app.jar"] links: - db depends_on: - db db: image: "mysql:latest" ports: - "3306:3306" volumes: - "/root/docker/mysql/datadir:/var/lib/mysql" restart: "always" environment: MYSQL_ROOT_PASSWORD: "123456" 参数及作用 参数 作用 image 指定创建容器的镜像 command 容器启动后执行的命令 container_name 指定容器的别名 ports 指定端口映射 voumes 指定目录挂载 links 指定连接的容器 depends_on 指定依赖的容器 environment 设置环境变量 working_dir 设置工作目录 restart 停止后是否重启 docker-compose 命令12345678#启动docker-compose up#后台启动docker-compose up -d#停止docker-compose stop#停止并移除docker-compose down 参考Docker Compose配置文件详解Docker Compose]]></content>
      <categories>
        <category>大后台</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>部署</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 介绍]]></title>
    <url>%2F2019%2F08%2F10%2FDocker%2F</url>
    <content type="text"><![CDATA[前言Docker 是一个开源的应用容器引擎，可以更快地构建和部署新应用程序。Docker 容器将软件及其依赖关系整合到一个标准化的软件开发单元中，包括运行所需的一切：代码，运行时，系统工具和库。这可以保证应用程序始终运行相同，并使协作变得像共享容器映像一样简单。 Docker 的优势对于开发人员来说 Docker 的优势主要是下面这几点： 加载更快，不需要再浪费时间设置开发环境，启动新的实例即可运行代码。 通过将配置依赖打包到一个镜像中，可以消除工作环境不一致所带来的一系列 BUG。 灵活迁移开发应用程序。 减轻对应用程序安全性的担忧。 如何安装关于安装这里主要介绍一个离线安装的方法。 下载一个对应的安装包。(地址) 解压 tar xzvf /path/to/&lt;FILE&gt;.tar.gz 复制文件到可执行目录 sudo cp docker/* /usr/bin/ 启动 Docker 守护进程 sudo dockerd &amp; 查看 Docker 是否安装成功 sudo docker info 常用命令一些常用的 Docker 命令记录 功能 命令 查看已安装的镜像 docker images 下载镜像 docker pull &lt;name&gt;:&lt;tag&gt; 删除镜像 docker rmi &lt;image_id&gt; 运行镜像 docker run &lt;image&gt; 停止容器 docker stop &lt;container&gt; 查看容器 docker ps 删除容器 docker rm &lt;container&gt; 删除全部已停止容器 docker container prune 将容器保存为镜像 docker commit &lt;container_id&gt; &lt;image&gt;:&lt;tag&gt; 镜像重命名 docker tag &lt;image_id&gt; &lt;new_name&gt;:&lt;tag&gt; 镜像导出 docker save -o &lt;file&gt; &lt;image&gt;:&lt;tag&gt; 镜像导入 docker load -i &lt;file&gt; 查看容器日志 docker logs &lt;container&gt; 进入运行中容器 docker exec -it &lt;container&gt; /bin/bash 一些 run 常用命令 选项 说明 -d 容器后台运行，并返回ID -i 以交互模式启动容器，常与 -t 同时使用 -t 给容器分配一个伪输入终端，常与 -i 同时使用 –name “name” 为容器指定一个别名 -e docker_host=127.0.0.1 设定环境变量 -m 设置容器使用内存最大值 -p [宿主端口]:[容器端口] 绑定端口映射 -v [宿主路径]:[容器路径] 挂载路径 -w [容器路径] 工作目录 –cpuset=”0-2” or –cpuset=”0,1,2” 绑定到指定cpu运行 –volumes-from [其他容器名] 将其他容器的数据卷添加到此容器 –link [其他容器名]:[在该容器中的别名] 添加链接到另一个容器 Dockerfile 的使用想要从一个基础镜像开始构建自定义镜像，可以一步步进行构建，也可以写一个配置文件快速构建。这个配置文件就是 Dockerfile。一个简单的 Dockerfile1234567891011121314FROM centos:7RUN yum install -y wgetRUN cd /ADD jdk-8u152-linux-x64.tar.gz /RUN wget http://apache.stu.edu.tw/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gzRUN tar zxvf apache-tomcat-7.0.82.tar.gzENV JAVA_HOME=/jdk1.8.0_152ENV PATH=$PATH:/jdk1.8.0_152/binCMD ["/apache-tomcat-7.0.82/bin/catalina.sh", "run"] 各个参数说明 FROM FROM &lt;image&gt;:&lt;tag&gt; 第一条必须为 FROM 指令，表示引用自哪个镜像 RUN RUN &lt;command&gt; 在 shell 终端中运行命令 CMD CDM [&quot;para1&quot;,&quot;para2&quot;] 指定容器的启动命令 EXPOSE EXPOSE &lt;port&gt; [&lt;port&gt;...] 告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。 ENV ENV &lt;key&gt; &lt;value&gt; 指定一个环境变量，并会在容器运行时保存 ADD ADD &lt;src&gt; &lt;dest&gt; 复制指定的 &lt;src&gt; 到容器中的 &lt;dest&gt;。 其中 &lt;src&gt; 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。 COPY COPY &lt;src&gt; &lt;dest&gt; 复制指定的 &lt;src&gt; 到容器中的 &lt;dest&gt;。 VOLUME VOLUME [&quot;/data&quot;] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 WORKDIR WORKDIR &lt;patj&gt; 为后续的命令指定工作目录 根据 Dockerfile 构建镜像命令docker build -t &lt;name&gt; 参考DockerDocker installDocker 常用指令详解Dockerfile 介绍]]></content>
      <categories>
        <category>大后台</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>部署</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装和配置]]></title>
    <url>%2F2019%2F05%2F28%2Fnginx%2F</url>
    <content type="text"><![CDATA[简介Nginx是俄罗斯人编写的十分轻量级的HTTP服务器。Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡服务器。下面将会介绍一下Nginx的安装和基本配置。 安装1234# 安装依赖yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel# 安装nginxyum -y install nginx 简单的命令123456# 启动服务nginx# 重启nginx -s reload# 关闭nginx -s stop nginx.conf配置文件默认配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748user nginx; #默认用户和用户组worker_processes auto; #允许生成的进程数error_log /var/log/nginx/error.log; #指定日志路径pid /run/nginx.pid; #指定nginx运行文件存放地址include /usr/share/nginx/modules/*.conf;events&#123; worker_connections 1024; #最大连接数&#125;http&#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #允许 sendfile 方式传输文件 tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; #连接超时时间 types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; #监听的端口 listen [::]:80 default_server; server_name _; #监听的地址 root /usr/share/nginx/html; #根目录位置(可以放在location中) #index index.html index.htm; #路径下默认的访问文件名(可以放在location中) include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; serverhttp服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。可以设置不同的监听地址和监听端口。 location12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ configuration G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ]&#125; 一些匹配符号的含义 已 = 开头表示精确匹配 ^~ 表示以某个url开头的地址 ~ 表示区分大小写的正则匹配 ~*表示不区分大小写的正则匹配 /通用匹配 优先级 location = location 完整路径 location ^~ 路径 location ~,~* 路径 location 部分起始路径 location / 参考博客nginx配置ssl证书实现https访问 nginx服务器安装及配置文件详解 nginx配置location总结及rewrite规则写法 Nginx配置详解]]></content>
      <categories>
        <category>大后台</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 标签记录]]></title>
    <url>%2F2019%2F04%2F19%2Fweb%E8%8F%9C%E9%B8%9F%E4%B9%8Bcss%2F</url>
    <content type="text"><![CDATA[记录一些常用的 css 标签 123456/*css设置标签的样式*/&lt;style type="text/css"&gt;span&#123; color:red;&#125;&lt;/style&gt; 12&lt;!--在html中写入css--&gt;&lt;span style="color:red;"&gt;&lt;/span&gt; 12&lt;!--引用外部css样式--&gt;&lt;link href="style.css" rel="stylesheet" type="text/css" /&gt; 就近原则：那个 css 样式设置离元素近，就采用哪种样式 1234/*类选择器,类名前面个加.*/.className&#123; color:red;&#125; 1234/*ID选择器，ID名称前加#*/#idName&#123; color:red;&#125; 1234/*子选择器(第一代后代)，在标签、类、ID选择器后添加 &gt;选择器*/.className&gt;span&#123; border:1px solid red;&#125; 1234/*后代选择器(所有后代),在标签、类、ID选择器后添加 (空格)选择器*/.className span&#123; border:1px solid red&#125; 1234/*通用选择器，匹配所有元素*/* &#123; color:red;&#125; 12345/*伪类选择器，给标签的某种状态设置样式*//*设置鼠标滑过a标签的样式*/a:hover&#123; color:red;&#125; 1234/*分组选择，给多组设置同一种样式*/a,.className,#id&#123; color:red;&#125; css 的某些样式的某些特性具有继承性，如 p 标签的 color 属性 权重：标签选择器 1 ，类选择器 10，ID选择器100 12/*插入important 浏览器采用当前样式*/p&#123;color:red!important;&#125; 123456789101112131415/*设置字体样式,大小，颜色,粗体,斜体，下划线，删除线，缩进，行高，字母间距离，单词间距离，位置左中右*/body&#123; font-family:Microsoft Yahei; font-size:12px; color:red; font-weight:bold; font-style:italic; text-decoration:underline; text-decoration:line-through; text-indent:2em; line-height:2em; letter-spacing:20px; word-spacing:20px; text-align:left,center,right;&#125; 常用块状元素： div , p , h1…h6 , ol , ul , dl , table , address , blockquote , form a{display:block;} 将元素设置为块状元素 特点： 每个块级元素都从新的一行开始，其后的元素也另起一行 元素的高度、宽度、行高、顶边距、底边距都可设置 元素宽度在不设置的情况下为父容器的100% 常用内联元素： a , span , br , i , em , strong , label , q , var , cire , code div{display:inline;}将元素设置为内联元素 特点： 和其他的元素在一行上 宽度、高度、顶边距、底边距不可设置 元素宽度就是内容宽度，不可改变 常用内联块状元素： img , input a{display:inline-block;}将元素设置为内联块状元素 特点： 和其他元素在一行上 宽度、高度、顶边距、底边距都可设置 12345678910111213/*盒模型边距*/div&#123; border-width:12px;/*边距大小*/ border-style:solid;/*边距样式，dashed虚线，dotted点线，solid实线*/ boder-color:red;/*颜色*/ /*简写*/ border:12px solid red; /*单独设置一边*/ border-left:1; border-top:2; border-right:3; border-bottom:4&#125; 1234/*填充 顺序为上、右、下、左*/div&#123;padding:10px 2px 10px 2px&#125;/*边距 顺序为上、右、下、左*/div&#123;margin:10px 2px 10px 2px&#125; css的3种基本布局模型: Flow 流动模型(网页默认布局) 块状元素会自上而下按顺序垂直布局 内联元素从左至右水平布局 Layer 浮动模型 float:left/right, 可以使块级元素并排显示 Float 层模式 绝对定位(position:absolute)：相对于最近一个有定位属性的位置，浮动在元素之上 12345div&#123; position:absolute; right:100px; top:20px;&#125; 相对定位(position:relative)：产生定位属性，元素相对于以前的位置产生了偏移，但是元素以前的位置还是保留着 12345div&#123; position:relative; right:100px; top:20px;&#125; 固定定位(position:fixed)：与absolute类似，但是是相对网页窗口固定 12345div&#123; position:fixed; right:100px; top:20px;&#125; 可以使用 text-align:center 来实现子元素的居中，但当子元素是块状元素时不适用，使用 margin:auto 使其居中 水平居中的方法 加入 table(包括 tbody , tr , td ) 标签作为父元素，table标签默认长度自适应 将块级元素改为 inline 类型，设置 text-align:center 通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 标签记录]]></title>
    <url>%2F2019%2F04%2F19%2Fweb%E8%8F%9C%E9%B8%9F%E4%B9%8Bhtml%2F</url>
    <content type="text"><![CDATA[记录一些常用的 HTML 标签 &lt;title&gt; 在 &lt;head&gt; 中，标题栏文字 &lt;em&gt;斜体字&lt;/em&gt; &lt;strong&gt;粗体字&lt;/strong&gt; &lt;span&gt;无语义标签，用作单独设置样式&lt;/span&gt; &lt;p&gt;段落标签&lt;/p&gt; 在前后都会有空白 &lt;q&gt;引用，会自动加上双引号&lt;/q&gt; &lt;blockquote&gt;引用，大段文本引用&lt;/blockquote&gt; &lt;br&gt;换行符 &amp;nbsp；空格 &lt;hr&gt; 分隔横线 &lt;address&gt;定义地址，默认表现为斜体&lt;/address&gt; &lt;code&gt;定义一行代码，样式改变&lt;/code&gt; &lt;pre&gt;保留标签内的回车和空格&lt;/pre&gt; 12345&lt;ul&gt; &lt;li&gt; 无序列表，有黑点，没有序号 &lt;/li&gt;&lt;/ul&gt; 12345&lt;ol&gt; &lt;li&gt; 有序列表，前面有序号 &lt;/li&gt;&lt;/ol&gt; 123456789101112131415&lt;!--表格以table开始--&gt;&lt;table&gt; &lt;!--tbody使表格能一块块地显示--&gt; &lt;tbody&gt; &lt;!--显示行--&gt; &lt;tr&gt; &lt;!--表头--&gt; &lt;th&gt;head&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--显示单元格--&gt; &lt;td&gt;content&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 123&lt;table summary="摘要，不显示方便搜索引擎查看"&gt; &lt;caption&gt;表格的标题&lt;/caption&gt;&lt;/table&gt; &lt;a href=&quot;跳转的网址&quot; title=&quot;鼠标滑过显示&quot;&gt;页面显示&lt;/a&gt; &lt;a href=&quot;网址&quot; target=&quot;_blank&quot;&gt;在新窗口中打开&lt;/a&gt; &lt;a href=&quot;mailto:abc@163.com?cc=抄送地址&amp;bcc=秘密抄送地址&amp;subject=主题&amp;body=neirong&quot;&gt;打开outlook发邮件&lt;/a&gt; &lt;img alt=&quot;图片加载失败显示&quot; src=&quot;图片地址&quot; title=&quot;鼠标滑过显示内容&quot;&gt; &lt;form method=&quot;get/post&quot; action=&quot;请求地址&quot;&gt;&lt;/form&gt; &lt;input type=&quot;输入类型&quot; name=&quot;上传参数名&quot; value=&quot;默认值&quot;&gt; type: text,文本框输入；password,密码输入 &lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本域&lt;/textarea&gt; 123&lt;label for="in_id"&gt;名称关联&lt;/label&gt;&lt;input id="in_id"&gt;&lt;/input&gt;&lt;!--label标签下的字段关联对应id标签，相当于对应标签的内容--&gt; &lt;input type=&quot;radio/checkbox&quot; value=&quot;选中提交的值&quot; name=&quot;字段名称&quot; checked=&quot;checked&quot;&gt;单选/多选&lt;/input&gt; 123456&lt;form&gt; &lt;!---multiple代表多选--&gt; &lt;select multiple="multiple"&gt; &lt;option value="1" selected="selected"&gt;下拉框选择&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; &lt;input type=&quot;submit&quot; value=&quot;显示的文字&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础]]></title>
    <url>%2F2019%2F03%2F10%2FRedis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言Redis由key-value组成的存储系统，其中value可以是string,hash,list,set,sorted set。 下载地址: Windows Linux 配置参数获取某一个参数 1config get &#123;config_name&#125; 获取全部参数 1config get * 编辑参数 1config set &#123;config_name&#125; &#123;config_value&#125; 具体参数含义可以参考这里 服务端配置 安装 1yum intall redis 用命令启动redis 1./redis-server 后台启动redis 修改/etc/redis.conf配置文件,将 daemonize no 改为 daemonize yes ./redis-server /etc/redis.conf启动redis 关闭redis 1./redis-cli shutdown 允许远程访问Redis服务器 修改 /etc/redis.conf 配置文件, bind 0.0.0.0 修改配置文件的 requirepass password , 添加密码 重启redis服务 五种数据库类型 字符串(string) 可以是字符串、整数或浮点数 set: 设置存储值 get: 获取存储值 del: 删除指定的键值 列表(list) 一个字符串的链表 rpush: 右侧插入 lpush: 左侧插入 lrange: 列出指定位置区间的值 lindex: 查询指定位置上的值 rpop: 右侧弹出 lpop: 左侧弹出 集合(set) 一个字符串的无序不重复的集合 sadd: 添加到集合 smember: 查询所有元素 sismember: 检查指定元素是否在 srem: 移除指定元素 散列(hash) 包含键值对的无序散列 hset: 设置键值 hget: 获取值 hgetall: 获取全部键值 hdel: 删除键值 有序集合(zset) 有序的set zadd: 添加元素 zrange: 列出区间内元素 zrangebyscore: 列出score区间内元素 zrem: 移除元素 参考文档菜鸟教程 《Redis实战》]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView自动换行]]></title>
    <url>%2F2019%2F01%2F13%2FTextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[前言TextView可以说是在Android中最常用的控件之一了。但是Text View中也有很多的坑，其中之一就是自动换行。 问题上面是网易新闻的列表截图，可以看到，“韩媒：中国已经抄袭了我们34个综”后面就进行换行了，给后面留下了较多的空白。像这种图片较多，每行之间间隔较大的列表来说也不是很明显。但像下面这种就显得比较难看了。 初步解决方案想到的思路是自己重写TextView的onDraw方法，只有到文字超出控件宽度时才换行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AlignText extends TextView &#123; private float textSize; private int textColor; private int paddingRight; private int paddingLeft; private float lineSpacing; private Paint paint; public AlignText(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); textSize = getTextSize(); textColor = getCurrentTextColor(); paddingLeft = getPaddingLeft(); paddingRight = getPaddingRight(); lineSpacing = getLineSpacingExtra(); &#125; protected void onDraw(Canvas canvas) &#123; if (paint == null) &#123; paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); &#125; int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; for (int i = 0; i &lt; textCharArray.length; i++) &#123; if (textCharArray[i] == &apos;\n&apos;) &#123; lineCount++; drawWidth = 0; continue; &#125; charWidth = paint.measureText(textCharArray, i, 1); if (textShowWidth - drawWidth &lt; charWidth) &#123; lineCount++; drawWidth = 0; &#125; float x=drawWidth + paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); canvas.drawText(textCharArray, i, 1, x, y, paint); drawWidth += charWidth; &#125; &#125;&#125; 存在的不足由上节代码可以看到，AlignText是在计算每一个字符的长度后判断是否需要换行。但是当一段文字中出现中英文或者标点符号时，由于不同的字符之间的宽度不同，在一段文字右侧也不能够完全对齐。 思考完善要解决上面提到的问题，我想到了两种方法： 由于单个汉字所占用空间是最大的，所以将所有的单个字符的宽度都设置为统一的宽度。 将最后的空白分配到之前的每一个字符的间隔之间。 方案一：123456789101112131415161718192021222324252627282930313233protected void onDraw(Canvas canvas)&#123; if (paint == null) &#123; paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); &#125; int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = paint.measureText(&quot;啊&quot;); for (int i = 0; i &lt; textCharArray.length; i++) &#123; if (textCharArray[i] == &apos;\n&apos;) &#123; lineCount++; drawWidth = 0; continue; &#125; if (textShowWidth - drawWidth &lt; charWidth) &#123; lineCount++; drawWidth = 0; &#125; float x=drawWidth + paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); canvas.drawText(textCharArray, i, 1, x, y, paint); drawWidth += charWidth; &#125;&#125;``` 效果&lt;img align=&quot;middle&quot; src=&quot;https://www.sisyphuser.cn/images/see/TextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C_4.jpg&quot;/&gt;&lt;/br&gt;方案二： protected void onDraw(Canvas canvas){ if (paint == null) { paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); } int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; int start = 0; int end = 0; for (int i = 0; i &lt; textCharArray.length; i++) { end++; if(i==textCharArray.length-1){ float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } if (textCharArray[i] == ‘\n’) { if (end-1 &gt; start) { float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } lineCount++; drawWidth = 0; start=i+1; continue; } charWidth = paint.measureText(textCharArray, i, 1); if (textShowWidth - drawWidth &lt; charWidth) { float addSpacing = (textShowWidth - drawWidth)/(end-2-start); float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize/8) (lineCount - 1)); int innerDrawWidth=0; for(int j= 0;j&lt;end-1-start;j++) { canvas.drawText(textCharArray, start+j, 1, x+innerDrawWidth+j*addSpacing, y, paint); float tempCharWidth=paint.measureText(textCharArray, start+j, 1); innerDrawWidth+=tempCharWidth; } lineCount++; drawWidth = 0; start=i; } drawWidth += charWidth; } }12345678效果&lt;img align=&quot;middle&quot; src=&quot;https://www.sisyphuser.cn/images/see/TextView%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C_6.jpg&quot;/&gt;&lt;/br&gt;### emoji问题在解决完对齐问题后发现了一个bug。原本能显示的emoji表情由于每次分开绘制字符变成了两个乱码符号。从[Emoji的编码以及常见问题处理](https://segmentfault.com/a/1190000007594620?utm_source=tuicool&amp;utm_medium=referral)中了解到一个emoji占了两个长度，而我把它截断了自然就显示乱码了。&lt;/br&gt;解决方案：对emoji的两个字符一起绘制，emoji的编码为(&apos;u&apos;\ud83c[\udf00-\udfff] | &apos;u&apos;\ud83d[\udc00-\ude4f\ude80-\udeff] | &apos;u&apos;[\u2600-\u2B55]) protected void onDraw(Canvas canvas){ if (paint == null) { paint = getPaint(); paint.setAntiAlias(true); paint.setColor(textColor); } int textShowWidth = getWidth() - paddingRight - paddingLeft; int lineCount = 1; String sContent = this.getText().toString(); char[] textCharArray = sContent.toCharArray(); float drawWidth = 0; float charWidth = 0; int start = 0; int end = 0; int defaultCount = 1; for (int i = 0; i &lt; textCharArray.length; i+=defaultCount) { end+=defaultCount; Log.i(“ssss”,String.valueOf(textCharArray[i])+defaultCount); if (textCharArray[i] == ‘\n’) { if (end-1 &gt; start) { float x = paddingLeft; float y = (lineCount) textSize + ((lineSpacing + textSize / 8) (lineCount - 1)); canvas.drawText(textCharArray, start, end - start, x, y, paint); } lineCount++; drawWidth = 0; start=i+1; defaultCount = 1; continue; } int index=(int)textCharArray[i]; if(i&lt;textCharArray.length-1 &amp;&amp;(index == 0xd83c ||index == 0xd83d || (index &gt;= 0x2600 &amp;&amp; index &lt;= 0x2B55))) { defaultCount = 2; }else{ defaultCount = 1; } charWidth = paint.measureText(textCharArray, i, defaultCount); if (textShowWidth - drawWidth &lt; charWidth) { float addSpacing = (textShowWidth - drawWidth)/(end-2-start); float x = paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize/8)* (lineCount - 1)); int innerDrawWidth=0; int innerDefaultCount = 1; for(int j= 0;j&lt;end-1-start;j+= innerDefaultCount) { int innerIndex=(int)textCharArray[start+j]; if(i&lt;textCharArray.length-1 &amp;&amp;(innerIndex == 0xd83c ||innerIndex == 0xd83d || (innerIndex &gt;= 0x2600 &amp;&amp; innerIndex &lt;= 0x2B55))){ innerDefaultCount = 2; }else{ innerDefaultCount = 1; } canvas.drawText(textCharArray, start+j, innerDefaultCount, x+innerDrawWidth+j*addSpacing, y, paint); float tempCharWidth=paint.measureText(textCharArray, start+j, innerDefaultCount); innerDrawWidth+=tempCharWidth; } lineCount++; drawWidth = 0; start=i; } if(i==textCharArray.length-defaultCount){ float x = paddingLeft; float y = (lineCount) * textSize + ((lineSpacing + textSize / 8) * (lineCount - 1)); canvas.drawText(textCharArray, start, textCharArray.length - start, x, y, paint); } drawWidth += charWidth; } }`]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS介绍]]></title>
    <url>%2F2018%2F07%2F20%2FHTTPS%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。接下来我会简单介绍一下https的通讯过程。 实现原理http默认使用80端口https默认使用443端口HTTPS 协议主要是为了保护用户隐私，防止流量劫持。https其实就是一个添加了加密认证的http，应用到了非对称加密和对称加密。关于非对称加密和对称加密的区别可以参考这个。 握手过程整个握手的过程可由下图表示 每个步骤传递的数据1.客户端发起请求，传输随机数、加密套件、支持的TLS协议版本等 2.服务端返回，随机数、选择一个支持的协议版本、加密证书 3.与CA验证证书有效性 4.客户端请求，生成随机数结合前两个随机数和约定的算法生成密钥，使用证书中的公钥加密传输生成的随机数 5.服务端，使用私钥获取加密传输中的随机数，用三个随机数和约定好的算法生成密钥，使用密钥用对称加密与客户端通讯验证 6.握手结束，使用密钥进行http加密通讯 参考大型网站的 HTTPS 实践（一）– HTTPS 协议和原理HTTPS协议详解(四)：TLS/SSL握手过程]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android6.0权限管理]]></title>
    <url>%2F2018%2F04%2F10%2FAndroid6.0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言Android6.0(API 23)引入了一种新的权限模式，即运行时应用权限管理。这种模式让用户能够更好地了解和控制权限，用户可为所安装的各个应用分别授予或撤销权限。对于开发者来说意味着在使用对应权限功能时必须要先判断权限是否已经赋予了。 危险权限对于权限的管理，并不是所有的权限都需要用户允许的，只有一部分危险权限需要许可。可以参照下图 检查、请求权限 在AndroidManifest中添加所需的权限 在使用危险权限功能前检查权限的状态 1checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED 当没有权限(检查权限状态不为PackageManager.PERMISSION_GRANTED)时请求权限 1requestPermissions(new String[]&#123;Manifest.permission.ACCESS_COARSE_LOCATION&#125;, 1); 在用户操作回掉中处理允许和拒绝操作的逻辑 12345678910111213@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;允许定位权限&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, &quot;拒绝定位权限！！！&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 其中在第三步中requestPermissions()可以一次请求多个权限，对于那些用户已经允许和拒绝并且勾选了不再提示的权限会直接执行回掉，并不会让用户再次选择授权。所以对于那些必须要要权限才能使用的功能可以在用户拒绝之后让用户在设置中手动打开权限。 123Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);intent.setData(Uri.fromParts(&quot;package&quot;, getPackageName(), null));startActivity(intent); 对于特殊机型的适配由于国内很多手机厂商早在Android6.0之前就有了自己的权限管理系统，在Android6.0之后有一些还保留着原有的权限管理系统。这导致了明明用checkSelfPermission()检查有权限但还是还是无法使用权限功能。例如VIVO在所有情况下checkSelfPermission()都是返回有权限，但他在使用到有关权限操作时会自动提示用户权限许可。不过这种情况下调用并不会导致系统报错，而且第三方厂商也做了使用权限的提示。下面以小米为例判断是否在小米中打开权限 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/***检查是由有权限**/private static boolean checkOpsPermission(Context context, String permission) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; try &#123; AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); String opsName = AppOpsManager.permissionToOp(permission); if (opsName == null) &#123; return true; &#125; int opsMode = appOpsManager.checkOpNoThrow(opsName, android.os.Process.myUid(), context.getPackageName()); return opsMode == AppOpsManager.MODE_ALLOWED; &#125; catch (Exception ex) &#123; return true; &#125; &#125; else &#123; return true; &#125;&#125;/** * 打开小米权限设置 */public void openPermissionSetting(Activity activity) &#123; String miuiVersion = getMiuiVersion(); Intent intent = null; if (&quot;V5&quot;.equals(miuiVersion)) &#123; Uri packageURI = Uri.parse(&quot;package:&quot; + activity.getApplicationInfo().packageName); intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI); &#125; else if (&quot;V6&quot;.equals(miuiVersion) || &quot;V7&quot;.equals(miuiVersion)) &#123; intent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); intent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;); intent.putExtra(&quot;extra_pkgname&quot;, activity.getPackageName()); &#125; else if (&quot;V8&quot;.equals(miuiVersion) || &quot;V9&quot;.equals(miuiVersion)) &#123; intent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); intent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;); intent.putExtra(&quot;extra_pkgname&quot;, activity.getPackageName()); &#125; if (null != intent) activity.startActivity(intent);&#125;/** * 获取MIUI版本 */public String getMiuiVersion() &#123; String line; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec(&quot;getprop ro.miui.ui.version.name&quot;); input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; return null; &#125; finally &#123; if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; return line;&#125; 参考Android 6.0 运行时权限处理完全解析权限最佳做法Android 6.0动态权限及小米（MIUI）权限的特殊处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令(下)]]></title>
    <url>%2F2018%2F04%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[前言在Git常用命令（上）中记录了一些添加提交文件的命令，而这篇将介绍一些关于版本回滚和分支管理的命令。 版本回退当发现新提交的版本有问题或者需要查看之前版本时可以使用版本回退功能。1git reset --hard HEAD 其中HEAD可以用提交时的版本号代替，可以是当前版本之前和之后的版本。 这是一个危险操作，他会替换掉工作区、暂存区和本地库中的内容，工作区和暂存区的内容将无法找回，本地库中的内容可以通过1git reset --hard &lt;版本号&gt; 找回，版本号可以通过 git reflog 来查找。使用 git reset –hard HEAD 回退后，在本地库中指针已经指向了对应的HEAD，需要把他同步到远程库。但是这时发现push到远程库失败， 原因是本地库比远程库的版本低（那是当然，刚才做了版本回退了啊），也不能执行pull，否则之前的操作就白费了。解决的办法是使用强制提交1git push -f origin master 除了用reset之外还可以使用revert进行回退1git revert &lt;版本号&gt; reset与revert的区别在与reset 是把HEAD向后移动了一下，而revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 分支在多人协作的开发中，需要有一个规范的工作流程。关于工作流程可以参考Git 工作流程,下面将介绍一些关于工作流程中分支的用法。1git branch &lt;branchName&gt; 创建分支1git checkout &lt;branchName&gt; 切换分支1git checkout -b &lt;branchName&gt; 创建并切换分支1git branch -d &lt;branchName&gt; 删除分支1git branch 查看全部分支，在当前分支前加上*1git merge &lt;branchName&gt; 将指定分支合并到当前分支1it merge --no-ff -m &quot;提交信息&quot; &lt;branchName&gt; 将指定分支合并到当前分支禁用 fast forward ,用这种方式提交会在当前分支生成一个合并分支的记录，方便之后的问题排查。1git rebase &lt;branchName&gt; 并入分支，这个和merge执行后的结果一致，但是实现的原理不同。merge只是合并分支，合并后当前分支的历史不变，只会新增目标分支的新的提交。而rebase则是先找到分支的起点，再将目标分支对应起点之后的各版本提交，然后提交当前分支对应起点的各版本。显然这会改变当前分支的历史，将不属于该分支的版本加入到当前分支中，会增加排查问题的难度。并入过程中可能会多次遇到冲突，可以在解决冲突后使用12git add .git rebase --continue 依次解决。rebase 需要遵循原则，即绝不要在公共的分支上使用它。1git log --graph --pretty=oneline --abbrev-commit 查看分支合并情况 blame1git blame &lt;fileName&gt; 用来查询该文件的修改记录 标签在每次发布版本或者新增重大功能时可以打上标签以方便以后的查询。1git tag &lt;tagName&gt; 创建标签1git tag -d &lt;tagName&gt; 删除标签1git push origin &lt;tagName&gt; 将标签推送到远程库 参考廖雪峰Git教程远程仓库版本回退方法Git分支管理策略代码合并：Merge、Rebase 的选择]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令(上)]]></title>
    <url>%2F2018%2F03%2F27%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[前言Git是一个优秀分布式版本控制系统，可以有效、高速的处理项目版本管理。在日常开发过程中经常会与之打交道，所以在下面记录了一些常用的Git命令。 创建ssh的公钥和私钥在git bush中输入1ssh-keygen -t rsa -C &quot;email@163.com&quot; 之后会需要输入保存key个文件位置和密码，这些都可以直接回车，默认的可以位置在C://用户/user/.ssh其中id_rsa.pub为公钥，id_rsa为私钥 以GitHub为例上传公钥再将公钥中的内容全部复制提交就可以了 设置git提交时的个人信息查看git基本信息配置1git config -l 设置显示的用户名1git config --global user.name &quot;Your Name&quot; 设置显示的邮箱1git config --global user.email &quot;email@163.com&quot; 关联远程库首先我们需要在GitHub上创建一个git库，这个很简单只要选择New repository然后按提示下一步就可以了。现在有了一个远程库，需要将本地的文件夹与他关联起来。注意在这里有两个远程库的地址 分别是”https://github.com...&quot;和&quot;git@github.com...&quot;。这两者的区别是”https://github.com...&quot;在每次执行需要权限的操作时都需要输入用户名和密码，而&quot;git@github.com...&quot;则需要先配置好SSH这就是第二部的操作，所以我选择使用&quot;git@github.com...&quot;来关联远程库。有两种关联的方法： 1) 如果没有本地文件可以直接clone1git clone git@github.com... 2) 如果有本地文件则可以在文件所在文件夹中执行1git init 创建本地库1git remote add origin git@github.com... 关联远程库 添加一个文件需要新增或修改一个文件时需要执行两部操作：add和commitadd:将工作区添加一个新建或修改的文件到暂存区1git add &lt;filename&gt; 添加特定的文件12git add --allgit add -A 添加所有的文件commit:将暂存区的文件提交到版本库中1git commit -m &quot;提交说明&quot; 当然也可以把两部操作合并1git commit -am &quot;提交说明&quot; 但是这个只适用于添加文件修改，对于新增的文件并不能添加。 关于.gitignore的使用.gitignore其实就是一个git的忽略文件。一般的匹配规则有三种： /filename/ 忽略目标文件夹 *.class 忽略所有匹配的.class文件 Test.class 忽略精确匹配的Test.class文件 当在.gitignore中声明了忽略文件后在git add –all中就会被跳过，也无法通过 git add 添加，但是可以使用 git add -f 强制添加。值得注意的是当一个文件已经被添加了，在暂存区中存在时，即使在.gitignore中声明了忽略也对这个文件无效。解决的方法是使用1git rm --cached -- &lt;filename&gt; 在暂存区中移除该文件。 工作区和暂存区对于工作区和暂存区简单的来说就是在add之前所有的变动操作都是在工作区，当add对文件生效后他就在暂存区了，commit提交的内容都只是暂存区的变更内容。关于工作区、暂存区和版本库之间的操作： 将工作区的更改保存到暂存区 1git add 将暂存区的更改保存到版本库 1git commit 从暂存区中删除文件而工作区不做更改 1git rm --cached -- &lt;filename&gt; 将暂存区的全部/指定文件替换工作区的文件 1git checkout . / git checkout -- &lt;filename&gt; 将版本库中全部/指定文件替换暂存区和工作区的文件 1git checkout HEAD . / git checkout HEAD &lt;filename&gt; 将版本库中全部/指定文件替换暂存区的文件而工作区不做更改 1git reset HEAD . / git reset HEAD &lt;filename&gt; 可以用一张图来直观地展示 一些查看Git状态的命令 查看工作区修改的内容 1git diff 查看提交的日志 1git log 查看提交的日志精简 1git log --pretty=oneline 查看每一次的命令及对应改动的版本 1git reflog 参考：Git工作区、暂存区和版本库廖雪峰Git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView的使用]]></title>
    <url>%2F2018%2F03%2F04%2FSurfaceView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在Android中更新UI操作都需要在主线程中操作。但是SurfaceView例外，他可以在子线程中更新View，这使他可以做一些复杂的动画更新而不必担心造成主线程的阻塞。接下来就开始介绍一下SurfaceView的使用。 实现SurfaceView通过SurfaceHolder.Callback来通知SurfaceView的创建和销毁12345678910111213surfaceView.holder.addCallback(object :SurfaceHolder.Callback&#123; //改变 override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; //销毁 override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; //创建 override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125;) 在SurfaceView创建完成之后就可以对其进行绘制了，而他的绘制是可以放在子线程中的 1234//获取画布val canvas=surfaceView.holder.lockCanvas()//提交画布surfaceView.holder.unlockCanvasAndPost(canvas) 创建动画下面就是一个使用SurfaceView创建动画的简单示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MainActivity : Activity() &#123; var surfaceView: SurfaceView? = null var mPath = Path() var mPaint = Paint(Paint.ANTI_ALIAS_FLAG) var mCanvas: Canvas? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) surfaceView = findViewById(R.id.surface_view) surfaceView.holder.addCallback(object:SurfaceHolder.Callback&#123; override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; mPaint.color = Color.BLACK mPaint.style = Paint.Style.STROKE mPaint.strokeWidth = 10f mPaint.strokeCap = Paint.Cap.ROUND mPaint.strokeJoin = Paint.Join.ROUND mPath.moveTo(0f, 100f) Thread(Runnable &#123; kotlin.run &#123; draw(0) &#125; &#125;).start() &#125; &#125;) &#125; private fun draw(x: Int) &#123; if (x &gt; 1080) &#123; return &#125; val y = (50 * Math.sin(x * Math.PI / 180) + 100).toInt() mPath.lineTo(x + 3f, y.toFloat()) try &#123; mCanvas = holder.svView.holder.lockCanvas() mCanvas?.drawColor(Color.WHITE) mCanvas?.drawPath(mPath, mPaint) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; if (mCanvas != null) holder.svView.holder.unlockCanvasAndPost(mCanvas) &#125; draw(x + 3) &#125;&#125; 其他用途SurfaceView还可以和MediaPlayer一起使用实现视频播放，以下就是简单的示例： 12345678910111213141516171819202122232425262728293031class MainActivity : Activity() &#123; var surfaceView: SurfaceView? = null val url = &quot;https://apd-fec3435b8e24a9f3815c886baf4b7682.v.smtcdns.com/om.tc.qq.com/A3h5f3r8PilbVshgbDGWN3dyaZ8zUFk92BfD1Npo4MBA/h0560ixm63g.mp4?sdtfrom=v1103&amp;guid=2cd4a548b5a2146345f8214435e93e24&amp;vkey=10A496F49B3530CF50C56B617F6DB75C6A69850F6E8AD27EF01C74C9B06E07A95E952146937CD25966DF570C447F3AA1570F392682DEEDA0953F1CA68941B5C3FD7552C0D4DC7666322C5B6EF983BCB32A09AD04252FD6CB536BBBB81CC1BAD7CB31E90E1D341D675E08ED216DCA77E0D868B2EE67C3D6F5&amp;platform=2&quot; val player = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) surfaceView = findViewById(R.id.surface_view) Thread(Runnable &#123; player.setDataSource(this, Uri.parse(url)) player.prepare() &#125;).start() surfaceView.holder.addCallback(object:SurfaceHolder.Callback&#123; override fun surfaceChanged(holder: SurfaceHolder?, p1: Int, p2: Int, p3: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; player.setDisplay(holder) &#125; &#125;) player.setOnPreparedListener(object : MediaPlayer.OnPreparedListener &#123; override fun onPrepared(p0: MediaPlayer?) &#123; player.start() player.isLooping = true &#125; &#125;) &#125;&#125; 参考SurfaceViewAndroid之SurfaceView使用总结Android SurfaceView的使用android中使用surfaceview＋MediaPlayer播放视频]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>SurfaceView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio自定义模板]]></title>
    <url>%2F2017%2F12%2F07%2FAndroid%20Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[前言在Android Studio如果我们需要新建一个Activity一般都会new一个Empty Activity。然而新建出来的结果往往还不是我们需要的，还需要进行一些修改。比如说Activity默认是继承AppCompatActivity而一般我都习惯写一个统一的父类来继承，并且在Activity中做一些初始化的操作，如果使用MVP模式还需要新建一个Presenter类。对于这些需求我一直都是在创建完后再进行修改和新建，直到我我看到了Android Studio的自定义模板。 目录文件首先我们找到AS默认模板的存放路径AS3.0\android-studio\plugins\android\lib\templates其中我们平时常用的模板就放在activity和other这两个文件夹下。先以最简单的EmptyActivity为例，他的结构目录是 root SimpleActivity.java.ftl SimpleActivity.kt.ftl globals.xml.ftl recipe.xml.ftl template.xml templat_black_activity.png 其中root目录下是模板ftl文件globals.xml.ftl是全局参数配置文件recipe.xml.ftl是控制文件创建和修改template.xml和templat_black_activity.png是创建时的UI界面控制 template.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template format=&quot;5&quot; revision=&quot;5&quot; name=&quot;TheMVP Activity&quot; minApi=&quot;9&quot; minBuildApi=&quot;14&quot; description=&quot;Creates a new empty activity with TheMVP&quot;&gt; &lt;category value=&quot;Activity&quot; /&gt; &lt;formfactor value=&quot;Mobile&quot; /&gt; &lt;parameter id=&quot;activityClass&quot; name=&quot;Activity Name&quot; type=&quot;string&quot; constraints=&quot;class|unique|nonempty&quot; suggest=&quot;$&#123;layoutToActivity(layoutName)&#125;&quot; default=&quot;MainActivity&quot; help=&quot;The name of the activity class to create&quot; /&gt; &lt;parameter id=&quot;delegateClass&quot; name=&quot;Delegate Name&quot; type=&quot;string&quot; constraints=&quot;class|unique|nonempty&quot; default=&quot;MainDelegate&quot; visibility=&quot;isCreateDelegate&quot; help=&quot;The name of the delegate class to create&quot; /&gt; &lt;parameter id=&quot;layoutName&quot; name=&quot;Layout Name&quot; type=&quot;string&quot; constraints=&quot;layout|unique|nonempty&quot; suggest=&quot;$&#123;activityToLayout(activityClass)&#125;&quot; default=&quot;activity_main&quot; visibility=&quot;isCreateDelegate&quot; help=&quot;The name of the layout to create for the activity&quot; /&gt; &lt;parameter id=&quot;linkedDelegate&quot; name=&quot;Linked Delegate&quot; type=&quot;string&quot; constraints=&quot;nonempty&quot; default=&quot;AppDelegate&quot; visibility=&quot;!isCreateDelegate&quot; help=&quot;Chose exists delegate&quot;/&gt; &lt;parameter id=&quot;isCreateDelegate&quot; name=&quot;Create Delegate&quot; type=&quot;boolean&quot; default=&quot;true&quot; help=&quot;If false, this delegate and layout will not be created&quot; /&gt; &lt;parameter id=&quot;packageName&quot; name=&quot;Package name&quot; type=&quot;string&quot; constraints=&quot;package&quot; default=&quot;com.mycompany.myapp&quot; /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=&quot;globals.xml.ftl&quot; /&gt; &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt;&lt;/template&gt; 上面就是template.xml和对应的创建UI示图。 template标签主要显示一些名称、描述和一些需要的版本信息，这里我写的测试模板名称为TheMVP Activity。 &lt; category value=”Activity” /&gt; 说明该标签放在Activity目录下，如果设置为Fragment则放在Fragment目录先下。 parameter标签就是主要的创建item的标签了 123456&lt;parameter id=&quot;packageName&quot; name=&quot;Package name&quot; type=&quot;string&quot; constraints=&quot;package&quot; default=&quot;com.mycompany.myapp&quot; /&gt; 这个是默认的选择包名的parameter 123456&lt;thumbs&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=&quot;globals.xml.ftl&quot; /&gt; &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt; 这三个是配置外部关联文件，template_blank_activity.png就显示在UI示图左边，globals.xml.ftl和recipe.xml.ftl将会在下面提到。 globals.xml.ftl1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;globals&gt;&lt;#if isCreateDelegate&gt; &lt;global id=&quot;superClass&quot; type=&quot;string&quot; value=&quot;ActivityPresenter&amp;lt;$&#123;delegateClass&#125;&amp;gt;&quot; /&gt;&lt;#else&gt; &lt;global id=&quot;superClass&quot; type=&quot;string&quot; value=&quot;ActivityPresenter&amp;lt;$&#123;linkedDelegate&#125;&amp;gt;&quot; /&gt;&lt;/#if&gt; &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt; &lt;global id=&quot;parentActivityClass&quot; value=&quot;&quot; /&gt; &lt;global id=&quot;simpleLayoutName&quot; value=&quot;$&#123;layoutName&#125;&quot; /&gt; &lt;global id=&quot;excludeMenu&quot; type=&quot;boolean&quot; value=&quot;true&quot; /&gt; &lt;global id=&quot;generateActivityTitle&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt; &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;&lt;/globals&gt; globals.xml.ftl中的内容比较简单，就是一些全局使用的值。这里有一个简单的逻辑标签123&lt;#if Boolean&gt;&lt;#else&gt;&lt;/#if&gt; rootroot目录下方的是一些作为模板的activity、layout、fragment文件 12345678910111213141516171819202122232425262728293031323334package $&#123;packageName&#125;.activityimport android.app.Activityimport android.content.Intentimport android.os.Bundleimport $&#123;applicationPackage&#125;.base.ActivityPresenter&lt;#if isCreateDelegate&gt;import $&#123;packageName&#125;.delegate.$&#123;delegateClass&#125;&lt;#else&gt;import $&#123;packageName&#125;.delegate.$&#123;linkedDelegate&#125;&lt;/#if&gt;class $&#123;activityClass&#125; : $&#123;superClass&#125;() &#123;&lt;#if isCreateDelegate&gt; override fun instanceDelegate(): $&#123;delegateClass&#125; &#123; return $&#123;delegateClass&#125;() &#125;&lt;#else&gt; override fun instanceDelegate(): $&#123;linkedDelegate&#125; &#123; return $&#123;linkedDelegate&#125;() &#125;&lt;/#if&gt; companion object &#123; fun start(activity: Activity) &#123; val intent=Intent(activity,$&#123;activityClass&#125;::class.java) start(activity,intent) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125;&#125; 写法也比较简单，与正常的代码一样，只是在一些位置将之前template.xml和globals.xml.ftl中输入和定义的值用${id}代替 recipe.xml.ftl123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot;?&gt;&lt;recipe&gt;&lt;#if generateKotlin&gt; &lt;instantiate from=&quot;root/src/app_package/SimpleActivity.kt.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.kt&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.kt&quot; /&gt; &lt;#if isCreateDelegate&gt; &lt;instantiate from=&quot;root/src/app_package/SimpleDelegate.kt.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/delegate/$&#123;delegateClass&#125;.kt&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/delegate/$&#123;delegateClass&#125;.kt&quot; /&gt; &lt;instantiate from=&quot;root/src/app_package/activity_simple.xml.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt; &lt;open file=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt; &lt;/#if&gt;&lt;/#if&gt; &lt;merge from=&quot;root/AndroidManifest.xml.ftl&quot; to=&quot;$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml&quot; /&gt;&lt;/recipe&gt; recipe是一个管理创建的文件，主要用到的操作标签有： copy：从root文件夹复制文件到目标文件夹 instantiate：从root中将对应的ftl文件经处理后转为目标文件 open：打开目标文件 merge：合并文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>自定义模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2使用]]></title>
    <url>%2F2017%2F03%2F16%2FDagger2%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[dagger2是一个依赖注入框架，可以用于功能模块的解耦，非常适合于和MVP搭配使用，下面就来介绍一下dagger2一些使用方式 导入项目库123456789dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;&#125;apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies &#123; compile &apos;com.google.dagger:dagger:2.4&apos; apt &apos;com.google.dagger:dagger-compiler:2.4&apos; compile &apos;org.glassfish:javax.annotation:10.0-b28&apos;&#125; 先来看一个简单的例子： 1234public class MainActivity extends AppCompatActivity &#123; @Inject B b;&#125; 在一个Activity中我需要一个B的实例，通常情况下我们直接b=new B();这样来初始化，但是使用了Dagger2之后就只需要添加一个@Inject注解就可以了。难道这样就可以了吗？不不不，我们还需要做一些配置 创建我们的测试类B 123456789101112public class B &#123; C c; @Inject public B(C c) &#123; this.c = c; &#125; public String geti() &#123; return &quot;result&quot;; &#125;&#125; 等等，这里只有一个构造方法，并且要传入C类，这个C类又是什么。我们一步步来，可以看到在构造方法上有一个@Inject，这个注解和MainActivity中的注解名称一样但是功能是不同的。在MainActivity中放在成员变量上面，是告诉dagger2我需要一个B的实例。在B中放在构造函数上面，是告诉dagger2可以用这个构造函数来创建B的实例。接下来就需要一个中间类来连接MainActivity和B，提供B的初始化条件C 创建MyComponent 1234 @Component(modules = MyModule.class)public interface MyComponent &#123; void inject(MainActivity a);&#125; 这里用到了@Component注解，告诉dagger2需要用到哪些Module 创建MyModule 123456public class MyModule &#123; @Provides public C provideB()&#123; return new C(); &#125;&#125; 提供了C类的实例 在MainActivity中初始化 1DaggerMyComponent.builder().myModule(new MyModule()).build().inject(this); DaggerMyComponent如果没有找到，可以build一下项目，这是一个由dagger2创建的实现了MyComponent的类 简单说先dagger2找到类的实例的基本步骤1. 查找Module中是否存在创建该类的方法。2. 若存在创建类方法，查看该方法是否存在参数2.1 若存在参数，则按从步骤1开始依次初始化每个参数2.2 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束3. 若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数3.1 若存在参数，则从步骤1开始依次初始化每个参数3.2 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 Qualifier(限定符)解决依赖注入迷失什么是依赖迷失？ 12345678910111213141516public class B &#123; C c; @Inject public B() &#123; &#125; @Inject public B(C c) &#123; this.c = c; &#125; public String geti() &#123; return &quot;result&quot;; &#125;&#125; 想上面的这种写法，当一个类中有两个或两个以上的构造方法时，dagger2就不知道用哪个构造方法来创建对象，这事就依赖迷失。当出现依赖迷失时项目编译时就会报错。Qualifier这时就可以发挥他的作用了，关于Qualifier有两种基本的用法 使用@Named注解在Module中 1234567891011@Provides@Named(&quot;c&quot;)public B provideB1(C c)&#123; return new B(c);&#125;@Provides@Named(&quot;qualifier&quot;)public B provideB2(C c)&#123; return new B();&#125; 在MainActivity中 123@Inject@Named(&quot;qualifier&quot;)B b; 自定义Qualifier注解创建注解 12345@Qualifier@Documented@Retention(RUNTIME)public @interface HasC &#123;&#125; 在Module中使用 1234567891011@Provides@HasCpublic B provideB1(C c)&#123; return new B(c);&#125;@Provides@NoCpublic B provideB2()&#123; return new B();&#125; 在MainActivity中使用 123@Inject@HasCB b; Component组织方式 依赖方式如上图中E的创建需要依赖C,F两个条件 1234567891011121314151617181920212223242526272829@Singleton@Component(modules = CModule.class)public interface AppComponent &#123; C c();&#125;@Modulepublic class CModule &#123; @Provides public C getc()&#123; return new C(); &#125;&#125;@UserScope@Component(dependencies = AppComponent.class,modules = BModule.class)public interface MainComponent &#123; void infect(MainActivity a);&#125;@Modulepublic class BModule &#123; @Provides @UserScope public B getb(C c)&#123; return new B(c); &#125;&#125; 在上述案例中MainComponent中的B创建需要依赖与AppComponent中的CModule，所以在MainComponent中添加AppComponent依赖dependencies = AppComponent.class，并在AppComponent中将C暴露出来 初始化，一般将AppComponent的初始化放在Application中build = DaggerAppComponent.builder().cModule(new CModule()).build(); MainActivity中的初始化 12345DaggerMainComponent.builder() .appComponent(App.build) .bModule(new BModule()) .build() .infect(this); 自定义的Scope 1234@Scope@Retention(RUNTIME)public @interface UserScope &#123;&#125; 包含方式 123456789101112131415@UserScope@Subcomponent(modules = BModule.class)public interface MainComponent &#123; void infect(MainActivity a);&#125;@Singleton@Component(modules = CModule.class)public interface AppComponent &#123; MainComponent m(BModule b);&#125;DaggerAppComponent.builder() .cModule(new CModule()) .build() .m(new BModule()) .infect(this); 继承方式这种方式比较复杂，需要Dagger2版本在2.7及以上，我在实现过程中总是出现一些奇怪的问题，在这里我只把Dependency Injection with Dagger 2中的代码贴上，等过段时间再回来研究 参考博客：Dependency Injection with Dagger 2浅析Dagger2的使用关于依赖注入框架dagger2的使用和理解Android：dagger2让你爱不释手-基础依赖注入框架篇Android：dagger2让你爱不释手-重点概念讲解、融合篇Android：dagger2让你爱不释手-终结篇]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Dagger2</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日/夜模式切换]]></title>
    <url>%2F2017%2F03%2F13%2F%E6%97%A5%E5%A4%9C%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[日/夜模式切换作为一个App的基本功能经常会被使用到，接下来就举出一些常用的日/夜模式切换的方法 使用UIMode的方法这种方式操作起来比较简单，就是将不同模式下的资源分开存放，然后调用方法切换资源即可 资源存放的路径 切换资源的方法 123456if (isNight) &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);&#125; else &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);&#125;recreate(); 其中AppCompatDelegate.MODE_NIGHT_YES代表切换到夜间模式，AppCompatDelegate.MODE_NIGHT_NO代表切换到日间模式如果是在新的Activity中切换日/夜模式则需要用RxBus(关于RxBus的用法可以参照我上篇博客)通知在后台的Activity调用recreate()重启Activity 最终效果 存在问题 由于需要recreate(),会重绘Activity导致屏幕闪烁，重新加载Avtivity时需要注意Activity内元素的保存 使用Theme通过切换不同的主题来实现切换日/夜模式的效果 在attrs.xml中设置主题中需要替换资源 12345&lt;resources&gt; &lt;attr name=&quot;bg&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;button_bg&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; &lt;attr name=&quot;button_tv&quot; format=&quot;color&quot;&gt;&lt;/attr&gt;&lt;/resources&gt; 设置日/夜模式主题 123456789101112131415 &lt;style name=&quot;Day&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;bg&quot;&gt;#FFFFFF&lt;/item&gt; &lt;item name=&quot;button_bg&quot;&gt;#A9A9A9&lt;/item&gt; &lt;item name=&quot;button_tv&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;Night&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;bg&quot;&gt;#4F4F4F&lt;/item&gt; &lt;item name=&quot;button_bg&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;button_tv&quot;&gt;#FFFFFF&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#828282&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#828282&lt;/item&gt;&lt;/style&gt; 在layout文件中使用arrts中的资源属性 1android:backgroundTint=&quot;?attr/button_bg&quot; 在Activity中切换主题 12345 if(isNight)&#123; setTheme(R.style.Night);&#125;else&#123; setTheme(R.style.Day);&#125; 设置主题需要放在setContentView()之前，所以每次切换完日/夜模式后都需要重新加载Activity 存在问题 与UIMode方法相同由于需要recreate(),会重绘Activity导致屏幕闪烁，并且在有比较多的属性需要修改时会导致style比较复杂 为了决解改变日/夜模式后屏幕闪烁的问题，我看了不少博客，终于找到了一个比较符合要求的项目，能够实现uiMode方法的不重建Activity切换日/夜模式。项目地址：https://github.com/geminiwen/SkinSprite 效果： 具体思路是在Activity创建View的过程中注入自己的代码。接下来分析一下这个lib的具体代码 首先是SkinnableActivity，继承自AppCompatActivity，在这个Activity中对View的创建进行拦截，我们主要关注三个方法 1)123456@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; LayoutInflater layoutInflater = LayoutInflater.from(this); LayoutInflaterCompat.setFactory(layoutInflater, this); super.onCreate(savedInstanceState);&#125; 注入自己的LayoutInflatorFactory，使inflate在这个LayoutInflaterFactory中执行 2) 12345678910111213@Overridepublic View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; if (mSkinnableViewInflater == null) &#123; mSkinnableViewInflater = new SkinnableViewInflater(); &#125; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mSkinnableViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ );&#125; 这是具体需要创建View的方法，可以看到他将具体的创建逻辑放到了SkinnableViewInflater中，这个类之后在做分析 3) 1234567891011121314public void setDayNightMode(@AppCompatDelegate.NightMode int nightMode) &#123; final boolean isPost21 = Build.VERSION.SDK_INT &gt;= 21; getDelegate().setLocalNightMode(nightMode); if (isPost21) &#123; applyDayNightForStatusBar(); applyDayNightForActionBar(); &#125; View decorView = getWindow().getDecorView(); applyDayNightForView(decorView);&#125; 这是一个我们之后需要切换日夜模式需要调用的方法，其中主要调用逻辑有1getDelegate().setLocalNightMode(nightMode); 对系统日/夜模式的资源进行切换 1234if (isPost21) &#123; applyDayNightForStatusBar(); applyDayNightForActionBar();&#125; 如果api等级大于等于21（即5.0及以上版本）则更换状态栏和标题栏资源1applyDayNightForView(decorView); 对于内容中的日/夜资源进行切换，这个方法我们可以看下他的具体实现 123456789101112131415private void applyDayNightForView(View view) &#123; if (view instanceof Skinnable) &#123; Skinnable skinnable = (Skinnable) view; if (skinnable.isSkinnable()) &#123; skinnable.applyDayNight(); &#125; &#125; if (view instanceof ViewGroup) &#123; ViewGroup parent = (ViewGroup)view; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; applyDayNightForView(parent.getChildAt(i)); &#125; &#125;&#125; 可以看到这是一个递归的方法，功能是遍历了view下所有的子view，对实现了Skinnable接口并且isSkinnable()返回true的view调用applyDayNight()。可以猜想到这些View就是自定义的View，这个applyDayNight()就是刷新View中资源的方法。 接下来可以看下上面的SkinnableViewInflater这个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public final View createView(View parent, final String name, @NonNull Context context,@NonNull AttributeSet attrs, boolean inheritContext,boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) &#123; final Context originalContext = context; // We can emulate Lollipop&apos;s android:theme attribute propagating down the view hierarchy // by using the parent&apos;s context if (inheritContext &amp;&amp; parent != null) &#123; context = parent.getContext(); &#125; if (readAndroidTheme || readAppTheme) &#123; // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); &#125; if (wrapContext) &#123; context = TintContextWrapper.wrap(context); &#125; View view = null; // We need to &apos;inject&apos; our tint aware Views in place of the standard framework versions switch (name) &#123; case &quot;TextView&quot;: view = new SkinnableTextView(context, attrs); break; case &quot;ImageView&quot;: view = new AppCompatImageView(context, attrs); break; case &quot;Button&quot;: view = new SkinnableButton(context, attrs); break; case &quot;EditText&quot;: view = new AppCompatEditText(context, attrs); break; case &quot;Spinner&quot;: view = new AppCompatSpinner(context, attrs); break; case &quot;ImageButton&quot;: view = new AppCompatImageButton(context, attrs); break; case &quot;CheckBox&quot;: view = new AppCompatCheckBox(context, attrs); break; case &quot;RadioButton&quot;: view = new AppCompatRadioButton(context, attrs); break; case &quot;CheckedTextView&quot;: view = new AppCompatCheckedTextView(context, attrs); break; case &quot;AutoCompleteTextView&quot;: view = new AppCompatAutoCompleteTextView(context, attrs); break; case &quot;MultiAutoCompleteTextView&quot;: view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case &quot;RatingBar&quot;: view = new AppCompatRatingBar(context, attrs); break; case &quot;SeekBar&quot;: view = new AppCompatSeekBar(context, attrs); break; case &quot;LinearLayout&quot;: view = new SkinnableLinearLayout(context, attrs); break; case &quot;FrameLayout&quot;: view = new SkinnableFrameLayout(context, attrs); break; case &quot;RelativeLayout&quot;: view = new SkinnableRelativeLayout(context, attrs); break; case &quot;android.support.v7.widget.Toolbar&quot;: view = new SkinnableToolbar(context, attrs); break; &#125; if (view == null &amp;&amp; originalContext != context) &#123; // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); &#125; if (view != null) &#123; // If we have created a view, check it&apos;s android:onClick checkOnClickListener(view, attrs); &#125; return view;&#125; 这个是SkinnableViewInflater中最主要的方法，根据name创建出不同的View，即自定义的View，这里并没有把所有的view都做出来，但是都大同小异，如果不够用还可以自己添加 最后只剩下View的没有看了，由于View比较多而且其中的内容都相似，我们拿SkinnableLinearLayout作为案例进行研究 123456789101112131415161718192021222324252627public SkinnableLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mAttrsHelper = new AttrsHelper(); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SkinnableView, defStyleAttr, 0); mAttrsHelper.storeAttributeResource(a, R.styleable.SkinnableView); a.recycle();&#125;@Overridepublic void applyDayNight() &#123; Context context = getContext(); int key; key = R.styleable.SkinnableView[R.styleable.SkinnableView_android_background]; int backgroundResource = mAttrsHelper.getAttributeResource(key); if (backgroundResource &gt; 0) &#123; Drawable background = ContextCompat.getDrawable(context, backgroundResource); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; setBackgroundDrawable(background); &#125; else &#123; setBackground(background); &#125; &#125;&#125; SkinnableLinearLayout中的思路也比较简单，在构造方法中向mAttrsHelper添加如属性，在需要刷新是再从mAttrsHelper中取出。对于不同的View也只是属性的内容不同而已 至此就是这个项目的大致源码，然后只需要将Activity继承SkinnableActivity,将uiMode中的AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);改为 setDayNightMode(AppCompatDelegate.MODE_NIGHT_YES); 并且不需要调用recreate()方法。需要注意的是还需要在该Activity中添加上android:configChanges=”uiMode”。 结语：这是我第一次写关于阅读源码的博客，尽管选了一个比较简单的lib但还是表达得比较凌乱。我之后还是会多多尝试写这方面的博客，努力提高自己的水平。 参考博客：android 实现【夜晚模式】的另外一种思路Android通过改变主题实现夜间模式Android实现日夜间模式的深入理解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RxJava的RxBus]]></title>
    <url>%2F2017%2F03%2F08%2F%E5%9F%BA%E4%BA%8ERxJava%E7%9A%84RxBus%2F</url>
    <content type="text"><![CDATA[RxBus是一个基于RxJava和RxAndroid的事件通讯工具 首先需要导入RxJava，RxAndroid库 12compile &apos;io.reactivex:rxandroid:1.2.1&apos;compile &apos;io.reactivex:rxjava:1.1.6&apos; RxBus基本代码 123456789101112131415161718192021222324252627public class RxBus &#123; private static volatile RxBus defaultInstance; private Subject&lt;Object,Object&gt; bus; public RxBus()&#123; bus=new SerializedSubject&lt;&gt;(PublishSubject.create()); &#125; //单例 public static RxBus getInstance()&#123; if(defaultInstance==null)&#123; synchronized(RxBus.class)&#123; if(defaultInstance==null)&#123; defaultInstance=new RxBus(); &#125; &#125; &#125; return defaultInstance; &#125; //发送一个事件 public void post(Object o)&#123; bus.onNext(o); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType)&#123; return bus.ofType(eventType); &#125;&#125; 使用 1. 发出事件 123Student s=new Student();s.setName(&quot;sss&quot;);RxBus.getInstance().post(s); 2.消费事件 123456789101112subscribe = RxBus.getInstance().toObservable(Student.class) //在io线程进行订阅，可以执行一些耗时操作 .subscribeOn(Schedulers.io()) //在主线程进行观察，可做UI更新操作 .observeOn(AndroidSchedulers.mainThread()) //观察的对象 .subscribe(new Action1&lt;Student&gt;() &#123; @Override public void call(Student s) &#123; Toast.makeText(MainActivity.this, s.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 3.在onDestory中移除订阅 1234567@Overrideprotected void onDestroy() &#123; super.onDestroy(); if(!subscribe.isUnsubscribed()) &#123; subscribe.unsubscribe(); &#125;&#125; 与EventBus相同RxBus也可以使用黏性事件修改过后的支持黏性事件的RxBus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class RxBus &#123; private static volatile RxBus defaultInstance; private final Map&lt;Class&lt;?&gt;,Object&gt; mStickyEventMap; private Subject&lt;Object,Object&gt; bus; public RxBus()&#123; bus=new SerializedSubject&lt;&gt;(PublishSubject.create()); mStickyEventMap=new ConcurrentHashMap&lt;&gt;(); &#125; //单例 public static RxBus getInstance()&#123; if(defaultInstance==null)&#123; synchronized(RxBus.class)&#123; if(defaultInstance==null)&#123; defaultInstance=new RxBus(); &#125; &#125; &#125; return defaultInstance; &#125; /** * 发送一个事件 * @param o */ public void post(Object o)&#123; bus.onNext(o); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType)&#123; return bus.ofType(eventType); &#125; //sticky事件 /** * 发送sticky事件 * @param event */ public void postSticky(Object event)&#123; synchronized (mStickyEventMap)&#123; mStickyEventMap.put(event.getClass(),event); &#125; post(event); &#125; public &lt;T&gt; Observable&lt;T&gt; toObservableSticky(final Class&lt;T&gt; eventType)&#123; synchronized (mStickyEventMap)&#123; Observable&lt;T&gt; observable = bus.ofType(eventType); final Object event=mStickyEventMap.get(eventType); if(event!=null)&#123; return observable.mergeWith(Observable.create(new Observable.OnSubscribe&lt;T&gt;() &#123; @Override public void call(Subscriber&lt;? super T&gt; subscriber) &#123; subscriber.onNext(eventType.cast(event)); &#125; &#125;)); &#125;else&#123; return observable; &#125; &#125; &#125; /** * 获取sticky事件 * @param eventType * @param &lt;T&gt; * @return */ public &lt;T&gt; T getStickyEvent(Class&lt;T&gt; eventType)&#123; synchronized(mStickyEventMap)&#123; return eventType.cast(mStickyEventMap.get(eventType)); &#125; &#125; /** * 移除指定的sticky事件 * @param eventType * @param &lt;T&gt; * @return */ public &lt;T&gt; T removeStickyEvent(Class&lt;T&gt; eventType)&#123; synchronized (mStickyEventMap)&#123; return eventType.cast(mStickyEventMap.remove(eventType)); &#125; &#125; /** * 移除所有sticky事件 */ public void removeAllStickyEvents()&#123; synchronized (mStickyEventMap)&#123; mStickyEventMap.clear(); &#125; &#125;&#125; 要发送黏性事件需要使用postSticky()发送事件使用toObservableSticky接受事件，与其他使用与普通事件相同 由于黏性事件保存在RxBus中，当不需要使用时除了要subscribe.unsubscribe()取消订阅还需要RxBus.getInstance().removeStickyEvent(Class);移除粘性事件 关于RxJava中的异常当RxJava中发生异常时会调用onError方法，并且结束整个订阅事件，这会导致之后发出的事件不能接受的问题，需要用try…catch…捕捉异常 参考博客：用RxJava实现事件总线(Event Bus)[深入RxBus]：支持Sticky事件[深入RxBus]：异常处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>RxJava</tag>
        <tag>RxAndroid</tag>
        <tag>事件通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object的clone方法]]></title>
    <url>%2F2017%2F03%2F07%2FJava%20Object%E7%9A%84clone%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Object中有clone()方法protected Object clone() throws CloneNotSupportedException clone()的作用是创建一个该对象的一个副本，并将对象的数据复制到该副本中 根据复制程度的不同，clone可以分为：浅拷贝：使用clone()即为浅拷贝，默认的拷贝方式是复制一个新的原对象，并赋予原对象相同的全局对象的值和引用。即原对象和复制对象的全局引用变量指向的是一个相同的对象空间。深拷贝：需要自己实现，即将原对象中的全局引用变量指向的对象也复制一份放入复制对象中。 这两个概念可能不太好理解，可以根据下面的案例来加深理解。 首先明确对Object clone的要求 实现Cloneable接口，如果不实现该接口会在clone方法中抛出CloneNotSupportedException异常 需要重写clone方法，clone方法在Object中是protect的，不能被外部访问，需要重写并修改为public的访问权限。 运行类 1234567891011121314151617181920212223242526class Test&#123; @Test public void ttt() throws CloneNotSupportedException &#123; A a=new A(); B b=new B(); a.setName(&quot;one&quot;); a.setB(b); b.setAge(1); A ca= (A) a.clone(); a.setName(&quot;two&quot;); a.getB().setAge(2); System.out.print(&quot;a.name=&quot;+a.getName()+&quot;\n&quot;+ &quot;a.b.age=&quot;+a.getB().getAge()+&quot;\n&quot;+ &quot;ca.name=&quot;+ca.getName()+&quot;\n&quot;+ &quot;ca.b.age=&quot;+ca.getB().getAge()); //打印 /* a.name=two a.b.age=2 ca.name=one ca.b.age=2 */ &#125;&#125; 12345678910111213141516171819202122232425class A implements Cloneable&#123; private String name; private B b; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public B getB() &#123; return b; &#125; public void setB(B b) &#123; this.b = b; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 12345678910111213141516class B implements Cloneable&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 上面的案例即为浅拷贝，可以看到ca为a的拷贝对象，但是两个对象的b指向的是同一个B的对象。 进行深拷贝：需要修改A中的clone方法 123456789@Overridepublic Object clone() throws CloneNotSupportedException &#123; A o=null; o=(A)super.clone(); if(o.b!=null)&#123; o.b=(B)o.b.clone(); &#125; return o;&#125; 在test中的打印结果为： 1234a.name=twoa.b.age=2ca.name=oneca.b.age=1 另一种利用序列化来实现对象的深拷贝需要序列化，首先要让A和B都实现Serializable接口在A中添加深拷贝方法 12345678public Object deepClone() throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream bo=new ByteArrayOutputStream(); ObjectOutputStream oo=new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi=new ObjectInputStream(bi); return oi.readObject();&#125; 该方法先将可序列化对象a写入流中，再将对象从流中读出来重建对象 参考博客：java.lang.Object.clone()分析Java Object对象之clone方法Object的clone()方法、深拷贝、浅拷贝]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Object clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门]]></title>
    <url>%2F2016%2F11%2F24%2Fpython%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[python这几天闲的无聊想做一个爬虫来爬取一些‘正经’网站，首先选择用python作为爬虫的语言。但是没有接触过python怎么办呢，只能从头开始学了。python学习地址这个是廖大神写的一个python入门，个人感觉写的非常不错，在粗略的学习了一遍之后感觉可以开始我的爬虫之旅了。 静态网页爬虫目标：抓取http://tieba.baidu.com/p/2166231880中妹子的图片保存在本地接下来分析一下我们需要做的事 获取网页html代码 将html中的图片地址提取出来 根据图片地址获取图片内容 将图片保存在本地 话不多少，直接上代码1234567891011121314151617181920from urllib import requestfrom html.parser import HTMLParserimport osclass MyHtml(HTMLParser): path=os.path.join(os.path.abspath(&apos;.&apos;),&apos;pic&apos;) if not os.path.exists(path): os.mkdir(path) def handle_starttag(self,tag,attrs): if tag==&apos;img&apos; and attrs[0][0]==&apos;pic_type&apos; and attrs[0][1]==&apos;0&apos;: print(attrs[2][1]) with request.urlopen(attrs[2][1]) as picdate: with open(os.path.join(self.path,attrs[2][1][-10:]),&apos;wb&apos;) as fd: fd.write(picdate.read())with request.urlopen(&apos;http://tieba.baidu.com/p/2166231880&apos;) as f: if f.status==200: parser=MyHtml() parser.feed(f.read().decode(&apos;utf-8&apos;)) else: print (&apos;url error&apos;) 这一部分都比较简单，用urllib获取到页面信息后，通过HTMLParser对有用的信息进行提取，然后再使用urllib加载图片保存到本地 获取含有js的复杂网页通过上一个例子我们已经对爬虫的爬取过程有了一个初步的了解，接下来我们需要接受更大的世界了。目标:https://mm.taobao.com/search_tstar_model.htm?spm=719.1001036.1998606017.2.pA4hNo首先想到的是通过之前的经验，先获取html再从html中加载图片信息。但是通过查看网页的源码后就发现，原来网页上的那么多的妹子的图片居然一张也没有在源码中显示。看来原来爬取静态网页的方法已经不适用了，我们要使用其他的手段了。 分析出现上述结果是因为网页上的图片项都是通过js添加进去的，那么我们有两种方法来解决这个问题： 分析js代码，找出添加的内容 先让js运行，我们从js处理完毕的html中获取我们想要的信息 这里我们选择第二种方法，为了让js运行就需要一些工具selenium+PhantomJSselenium是一个自动化测试工具，可以同过 pip install selenium 来安装PhantomJS其实就是一个浏览器，只是它没有界面，我们的js就是依赖它来执行的。http://phantomjs.org/download.html从这个地址下载，把其中的phantomjs.exe文件放在python目录下（确保你的python目录已经在环境变量中配置好了） 还有一个非常实用的爬虫工具需要安装pip install beautifulsoup4，这个是用来提取html元素的。如果不是很了解可以参考这篇文章好了，准备工作都做好了，可以开工了 1234567891011121314151617181920212223242526272829303132333435363738394041424344from urllib import requestfrom bs4 import BeautifulSoupfrom selenium import webdriverimport osimport timeclass MyHtml(): def __init__(self): self.host=&apos;https://mm.taobao.com/search_tstar_model.htm?spm=719.1001036.1998606017.2.pA4hNo&apos; self.path=os.path.join(os.path.abspath(&apos;.&apos;),&apos;mm&apos;) if not os.path.exists(self.path): os.mkdir(self.path) self.browser=webdriver.PhantomJS() self.count=0 def start(self,n=False): if not n: print(self.host) self.browser.get(self.host) print(&apos;第&apos;+str(self.count)+&apos;项&apos;) self.soup=BeautifulSoup(self.browser.page_source) for li in self.soup.find_all(&apos;li&apos;,class_=&apos;item&apos;): self.img=li.find(&apos;img&apos;) if self.img.has_attr(&apos;data-ks-lazyload&apos;): self.src=&apos;https:&apos;+self.img[&apos;data-ks-lazyload&apos;] else: self.src=&apos;https:&apos;+self.img[&apos;src&apos;] print(self.src) self.name=str(li.find(&apos;span&apos;,class_=&apos;name&apos;).string) try: with request.urlopen(self.src) as pic: if pic.status==200: with open(os.path.join(self.path,self.name+&apos;.jpg&apos;),&apos;wb&apos;) as pici: pici.write(pic.read()) except BaseException: print(&apos;这个地址有问题&apos;) if self.count&lt;10:#数据太多这里只取前十项 self.browser.find_element_by_class_name(&apos;page-next&apos;).click() # time.sleep(3) self.start(True) self.count=self.count+1if &apos;__main__&apos;==__name__: MyHtml().start() 最后到这里我们已经知道了python爬虫的入门用法。但是我们发现这个爬虫的效率太低，这时可以用多线程提高爬虫效率。当同一个ip在一个网站访问频率太高时可能会出现验证码，这时需要做访问延迟和使用代理ip。爬虫路还很长，还有许多知识需要学习。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide图片加载]]></title>
    <url>%2F2016%2F10%2F26%2FGlide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Glide是一款bumptech发布，并被Google推荐使用的图片加载库。项目地址是https://github.com/bumptech/glide，本文不会对Glide的内存占用和性能进行分析，只是介绍Glide的基本用法。 导入库12compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;compile &apos;com.android.support:support-v4:19.1.0&apos; 基本操作12345Glide.with(context) //关联activity或fragment的生命周期 .load(url) //加载地址(url,资源id，本地图片file) .placeholder(id) //未加载时的占位图 .error(id) //加载失败时的占位图 .into(ImageView); //加载对象 基本配置Glide的配置是通过实现GlideModule接口来设置。 123456789public class MyGlideModule implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; &#125; @Override public void registerComponents(Context context, Glide glide) &#123; &#125;&#125; 然后需要在AndroidManifest.xml中声明 123&lt;meta-data android:name=&quot;com.shangbang.store.base.MyGlideModule&quot; android:value=&quot;GlideModule&quot; /&gt; 由于Glide是通过反射将GlideModule实例化得，所以需要在混淆文件中加入-keep public class * implements com.bumptech.glide.module.GlideModule 接下来介绍一些Glide的常用配置 配置图片本地缓存位置和本地缓存大小 123456789101112public void applyOptions(final Context context, GlideBuilder builder) &#123; builder.setDiskCache(new DiskCache.Factory() &#123; @Override public DiskCache build() &#123; //缓存的文件夹 File cacheLocation = new File(context.getExternalCacheDir(), &quot;glide&quot;); if (!cacheLocation.exists()) cacheLocation.mkdirs(); return DiskLruCacheWrapper.get(cacheLocation, 250 * 1024 * 1024);//本地缓存的大小 &#125; &#125;);&#125; 设置解码格式Glide默认的采用的使RGB_565，如果你对图片的质量要求较高可以采用ARGB_8888格式，缺点是ARGB_8888的内存占用是RGB_565的两倍。此外，ARGB_8888是支持透明格式的，而RGB_565不支持。 123 public void applyOptions(final Context context, GlideBuilder builder) &#123; builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);&#125; 特殊要求的使用 缓存策略 12345 .diskCacheStrategy(Type) //设置缓存到本地的策略DiskCacheStrategy.NONE //不会缓存到本地DiskCacheStrategy.SOURCE //只缓存原图DiskCacheStrategy.RESULT //只缓存最终图像（默认）DiskCacheStrategy.ALL //缓存所有图像 图片格式设置Glide中给了两种图片的放入格式，需要注意的是使用Glide的图片格式时就不要在ImageView中设置scaleType了，否则可能会使Glide的图片格式失效。 12.centerCrop() //自适应控件大小.fitCenter() //适应图片大小 加载优先级 12345 .priority(TYPE) //优先级由低到高Priority.LOWPriority.NORMALPriority.HIGHPriority.IMMEDIATE 缩略图 1234Glide.with(this) .load(&quot;http://my.csdn.net/uploads/201205/06/1336311585_2632.gif&quot;) .thumbnail(0.1f) .into(iv); 利用thumbnail(0.1f)来设置先加载0.1f的缩略图显示，然后再加载需要的图缩略图原图 自定义图片转化这里以制作圆形头像为例介绍.transform()的使用1234Glide.with(context) .load(url) .transform(new CircleTransform(context)) .into(imageView); 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CircleTransform extends BitmapTransformation &#123; public CircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool,toTransform); &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; int size = Math.min(source.getWidth(), source.getHeight()); int width = (source.getWidth() - size) / 2; int height = (source.getHeight() - size) / 2; Bitmap bitmap = pool.get(size, size, Bitmap.Config.ARGB_8888); if (bitmap == null) &#123; bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); BitmapShader shader = new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP); if (width != 0 || height != 0) &#123; // source isn&apos;t square, move viewport to center Matrix matrix = new Matrix(); matrix.setTranslate(-width, -height); shader.setLocalMatrix(matrix); &#125; paint.setShader(shader); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return bitmap; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 回调bitmap 123456private SimpleTarget target = new SimpleTarget&lt;Bitmap&gt;( 250, 250 ) &#123; //250,250可不加，表示原图大小 @Override public void onResourceReady(Bitmap bitmap, GlideAnimation glideAnimation) &#123; imageView2.setImageBitmap( bitmap ); &#125; &#125;; 12345Glide .with( context.getApplicationContext() ) // safer! .load( url ) .asBitmap() .into( target ); 利用这种方法可以直接获得bitmap，然后可以根据需要对Bitmap进行处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>图片加载</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP模式]]></title>
    <url>%2F2016%2F09%2F23%2FMVP%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言MVP是一种MVC的变形，相比MVC它大大减少了Activity的责任将主要的逻辑操作集中在Presenter层中，从而使得MVP的代码结构变得更清晰。 MVP结构MVP主要由Model、View、Presenter三部分构成。Model:负责数据的处理，即数据的获取、存储、解析、分发、修改等操作；View:即Activity和Fragment，负责页面的绘制，刷新；Presenter:负责连接Model层和View层，从Model中获取数据然后控制View刷新页面，是主要逻辑操作的地方。 这里借用此文的一张图片来表示Model、View和Presenter三者的关系 MVP案例这是一个简单的菜谱App，主要包括列表和详情，下面以列表页威力展示一下MVP的运用。 列表页视图: 项目结构: (1)Model层这里的Model主要负责从网络获取数据123456789public interface ITypeListModel &#123; void loadList(String url, Map&lt;String,String&gt; paraMap, TypeListListener listener); void cancle(); interface TypeListListener&#123; void loadSuccess(String json,Map&lt;String,String&gt; hMap); void loadFail(Exception e,Map&lt;String,String&gt; hMap); &#125;&#125; 1234567891011121314151617181920212223242526272829public class TypeListModel implements ITypeListModel &#123; private RequestCall call; @Override public void loadList(String url, final Map&lt;String, String&gt; paraMap, final ITypeListModel.TypeListListener listener) &#123; call= OkHttpUtils.post() .url(url) .params(paraMap) .build(); call.execute(new StringCallback() &#123; @Override public void onError(Call call, Exception e, int id) &#123; listener.loadFail(e,paraMap); &#125; @Override public void onResponse(String response, int id) &#123; listener.loadSuccess(response,paraMap); &#125; &#125;); &#125; @Override public void cancle() &#123; if(call!=null) call.cancel(); &#125;&#125; (2)View层View层管理点击页面上控件的状态和控件的点击事件我将View和Presenter的两个接口都放在了Contract中方便管理 12345678910111213141516171819interface View&#123; void showLoading(); void hideLoading(); void showLoadFail(); void hideLoadFail(); void showContent(); void hideContent(); void toastMessage(String message); void setContentData(List&lt;FoodTypeGroup&gt; list);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class FoodTypeActivity extends AppCompatActivity implements FoodTypeContract.View, View.OnClickListener, ExpandableListView.OnChildClickListener &#123; @Bind(R.id.tv_head_back) View tvBack; @Bind(R.id.tv_head_title) TextView tvTitle; @Bind(R.id.elv_content) ExpandableListView elvContent; @Bind(R.id.progressBar) View progressBar; @Bind(R.id.tv_fail) View tvFail; private FoodTypeAdapter adapter; private List&lt;FoodTypeGroup&gt; adapterList; private FoodTypeContract.Presenter foodTypePresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_food_type); ButterKnife.bind(this); foodTypePresenter=new FoodTypePresenter(this); initView(); initAdapter(); foodTypePresenter.start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); foodTypePresenter.onDestroy(); &#125; private void initView() &#123; tvBack.setVisibility(View.GONE); tvTitle.setText(&quot;菜品分类&quot;); tvFail.setOnClickListener(this); elvContent.setOnChildClickListener(this); &#125; private void initAdapter()&#123; adapterList=new ArrayList&lt;&gt;(); adapter=new FoodTypeAdapter(this,adapterList); elvContent.setAdapter(adapter); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.tv_fail://重新加载 foodTypePresenter.start(); break; &#125; &#125; @Override public boolean onChildClick(ExpandableListView expandableListView, View view, int i, int i1, long l) &#123; Intent intent=new Intent(this,TypeListActivity.class); intent.putExtra(&quot;id&quot;,adapterList.get(i).getList().get(i1).getId()); intent.putExtra(&quot;type&quot;,adapterList.get(i).getList().get(i1).getName()); startActivity(intent); return true; &#125; @Override public void showLoading() &#123; progressBar.setVisibility(View.VISIBLE); &#125; @Override public void hideLoading() &#123; progressBar.setVisibility(View.GONE); &#125; @Override public void showLoadFail() &#123; tvFail.setVisibility(View.VISIBLE); &#125; @Override public void hideLoadFail() &#123; tvFail.setVisibility(View.GONE); &#125; @Override public void showContent() &#123; elvContent.setVisibility(View.VISIBLE); &#125; @Override public void hideContent() &#123; elvContent.setVisibility(View.GONE); &#125; @Override public void toastMessage(String message)&#123; ToastUtil.showToast(this,message); &#125; @Override public void setContentData(List&lt;FoodTypeGroup&gt; list) &#123; adapterList.clear(); adapterList.addAll(list); adapter.notifyDataSetChanged(); &#125;&#125; (3)Presenter层从View中接收到获取列表请求后调用Model获取列表数据，根据列表数据的状态控制View作不同的显示 1234567interface Presenter extends BasePresenter&#123; @Override void start(); @Override void onDestroy();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class FoodTypePresenter implements FoodTypeContract.Presenter&#123; private FoodTypeContract.View foodTypeView; private IFoodTypeModel iFoodTypeModel; public FoodTypePresenter(FoodTypeContract.View foodTypeView)&#123; this.foodTypeView=foodTypeView; iFoodTypeModel=new FoodTypeModel(); &#125; @Override public void start() &#123; foodTypeView.hideContent(); foodTypeView.hideLoadFail(); foodTypeView.showLoading(); final Map&lt;String,String&gt; paraMap=new HashMap&lt;&gt;(); paraMap.put(&quot;key&quot;,BaseUrl.KEY); iFoodTypeModel.loadList(BaseUrl.FOODTYPE, paraMap, new IFoodTypeModel.FoodTypeListener() &#123; @Override public void loadSuccess(String json) &#123; LoadSuccess.onSuccess(json, new LoadSuccess.LoadSuccessCallBack() &#123; @Override public void code200(JSONObject json) throws JSONException &#123; if(foodTypeView!=null) &#123; List&lt;FoodTypeGroup&gt; list = JSON.parseArray(json.getJSONArray(&quot;result&quot;).toString(), FoodTypeGroup.class); foodTypeView.hideLoading(); foodTypeView.showContent(); foodTypeView.setContentData(list); &#125; &#125; @Override public void codeOther(String errorMessage) &#123; if(foodTypeView!=null) &#123; foodTypeView.hideLoading(); foodTypeView.showLoadFail(); foodTypeView.toastMessage(errorMessage); &#125; &#125; &#125;); &#125; @Override public void loadFail(Exception e) &#123; L.e(&quot;NET&quot;,e.getMessage()); if (foodTypeView!=null) &#123; foodTypeView.hideLoading(); foodTypeView.showLoadFail(); foodTypeView.toastMessage(&quot;网络连接异常&quot;); &#125; &#125; &#125;); &#125; @Override public void onDestroy()&#123; iFoodTypeModel.cancle(); foodTypeView=null; &#125;&#125; 项目地址https://github.com/NevLight/Fish]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar的使用]]></title>
    <url>%2F2016%2F09%2F21%2FToolbar%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在Android Studio中默认工程继承AppCompatActivity而不是Activity。从AppCompatActivity的源码中可以看到，它是继承自FragmentActivity的而它的另一个作用是代替了过时的ActionBarActivity，即用Toolbar代替ActionBar。接下来就介绍一下Toolbar的使用。 导入依赖包compile ‘com.android.support:appcompat-v7:24.1.1’ xml中设置12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/tool&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 在Activity中设置Toolbar基本设置1.设置标题12setTitle(&quot;title&quot;);setSupportActionBar(toolbar); 默认标题是靠右对齐，如果要居中或对标题样式有特殊需求可以在xml中的Toolbar标签中加入并配置其属性2.设置返回按钮1234567tool.setNavigationIcon(R.mipmap.back); tool.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(getWindow().getDecorView(),&quot;back&quot;,Snackbar.LENGTH_SHORT).show(); &#125; &#125;); 3.设置logo1tool.setLogo(R.mipmap.logo); 4.设置副标题1tool.setSubtitle(&quot;subtitle&quot;); 设置完以上参数的样式如下 menu设置1.menu基本设置在代码中设置获取menu1234567891011@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.food_type_menu,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; //各个item点击事件 return true; &#125; 在menu中设置menu样式1234567891011121314151617 &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &gt; &lt;item android:id=&quot;@+id/menu_group&quot; android:title=&quot;item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; app:showAsAction=&quot;always&quot; /&gt; &lt;item android:id=&quot;@+id/menu_clear&quot; android:title=&quot;item1&quot; app:showAsAction=&quot;never&quot; /&gt; &lt;item android:id=&quot;@+id/menu_refresh&quot; android:title=&quot;item2&quot; app:showAsAction=&quot;never&quot; /&gt;&lt;/menu&gt; 其中showAsAction属性共有五个值：ifRoom、never、always、withText、collapseActionView，可以混合使用。ifRoom 会显示在Item中，但是如果已经有4个或者4个以上的Item时会隐藏在溢出列表中。当然个数并不仅仅局限于4个，依据屏幕的宽窄而定never 永远不会显示。只会在溢出列表中显示，而且只显示标题，所以在定义item的时候，最好把标题都带上。always 无论是否溢出，总会显示。withText withText值示意Action bar要显示文本标题。Action bar会尽可能的显示这个标题，但是，如果图标有效并且受到Action bar空间的限制，文本标题有可能显示不全。collapseActionView 声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，并且即便在用于不适用的时候，也要占据操作栏的有效空间。一般要配合ifRoom一起使用才会有效果。 最终效果 2.menu样式默认的样式是白底黑字，可以通过设置Toolbar中的theme来改变样式1234&lt;!--&lt;style name=&quot;MenuStyle&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt;--&gt;&lt;style name=&quot;MenuStyle&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#ffffff&lt;/item&gt;&lt;/style&gt; 以上两个parent，ThemeOverlay.AppCompat.Light为白色背景ThemeOverlay.AppCompat.Dark.ActionBar为黑色背景，android:textColorPrimary设置字体颜色3.PopupMenuPopupMenu是一个轻量话的控件，与PopupWindow相比少了很多自定义的属性，这里我将PopupWindow作为一个Menu的展开来使用1234567891011121314151617PopupMenu popup=new PopupMenu(this,findViewById(R.id.menu_group));popup.getMenuInflater().inflate(R.menu.food_type_menu_item,popup.getMenu());popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; switch (item.getItemId())&#123; case R.id.item1: ToastUtil.showToast(FoodTypeActivity.this,&quot;item1&quot;); break; case R.id.item2: ToastUtil.showToast(FoodTypeActivity.this,&quot;item2&quot;); break; &#125; return true; &#125;&#125;);popup.show(); 如果需要改变PopupMenu的字体颜色和背景颜色就需要在该window对应的Activity中改变它的style1234&lt;style name=&quot;PpupmenuStyle&quot; parent=&quot;@style/AppTheme&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#ffffff&lt;/item&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt;&lt;/style&gt; 在AndroidManifest中设置style1&lt;activity android:name=&quot;.view.FoodTypeActivity&quot; android:theme=&quot;@style/PpupmenuStyle&quot;/&gt; 默认PopupMenu是只显示title不显示icon的，可以自己重写PopupMenu并修改相关属性来使之显示icon12345678try &#123; Field field = popup.getClass().getDeclaredField(&quot;mPopup&quot;); field.setAccessible(true); MenuPopupHelper mHelper = (MenuPopupHelper) field.get(popup); mHelper.setForceShowIcon(true);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 结尾以上就是关于Toolbar的一些东西，虽然常用的都是自定义的title，但还是有必要了解一下官方给的方案。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText基础属性]]></title>
    <url>%2F2016%2F09%2F09%2FEditText%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.限制输入字符的长度(1)在xml中设置12&lt;EditText android:maxLines=&quot;11&quot;/&gt; (2)在代码中设置1editText.setFilters(new InputFilter[]&#123;new InputFilter.LengthFilter(11)&#125;); (3)对超出的长度给出提示1234567891011121314151617181920editText.addTextChangedListener(new TextWatcher() &#123; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; if(s.length()&gt;11)&#123; Toast.makeText(context, &quot;长度超出限制&quot;, Toast.LENGTH_LONG); editText.setText(s.subSequence(0, s.length()-1)); editText.setSelection(editText.getText().length()); &#125; &#125; &#125;); 2.输入类型的限制(1)限制只能输入指定类型1android:digits=&quot;0123456789xyzXYZ&quot; (2)特殊输入内容的限制1android:inputType=&quot;text&quot; 其中intputType的属性有 android:inputType=”textCapCharacters” 字母大写 android:inputType=”textCapWords” 首字母大写 android:inputType=”textCapSentences” 仅第一个字母大写 android:inputType=”textAutoCorrect” 自动完成 android:inputType=”textAutoComplete” 自动完成 android:inputType=”textMultiLine” 多行输入 android:inputType=”textImeMultiLine” 输入法多行（如果支持） android:inputType=”textNoSuggestions” 不提示 android:inputType=”textUri” 网址 android:inputType=”textEmailAddress” 电子邮件地址 android:inputType=”textEmailSubject” 邮件主题 android:inputType=”textShortMessage” 短讯 android:inputType=”textLongMessage” 长信息 android:inputType=”textPersonName” 人名 android:inputType=”textPostalAddress” 地址 android:inputType=”textPassword” 密码 android:inputType=”textVisiblePassword” 可见密码 android:inputType=”textWebEditText” 作为网页表单的文本 android:inputType=”textFilter” 文本筛选过滤 android:inputType=”textPhonetic” 拼音输入 android:inputType=”number” 数字 android:inputType=”numberSigned” 带符号数字格式 android:inputType=”numberDecimal” 带小数点的浮点格式 android:inputType=”phone” 拨号键盘 android:inputType=”datetime” 时间日期 android:inputType=”date” 日期键盘 android:inputType=”time” 时间键盘]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>EditText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava的简单使用]]></title>
    <url>%2F2016%2F09%2F09%2FRxJava%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[为什么要用RxJava最近发现越来越多的项目开始使用RxJava，那么他到底有什么优势呢。总结来说有两点：1.代码简洁、逻辑清晰，避免了处理复杂逻辑时的大量代码嵌套2.线程自由控制，能够多次自由地切换线程，满足复杂异步操作的需求 RxJava的使用RxJava的主要组成是两个核心类Observables(被观察者、事件源)，Subscribers(观察者),实现完核心类后用subscribe()将两着订阅起来要使用RxJava首先引入两个依赖compile ‘io.reactivex:rxandroid:1.2.1’compile ‘io.reactivex:rxjava:1.1.6’接下来贴出几个小例子来简单演示RxJava的使用最基础的使用123456789101112131415161718192021222324252627//创建事件源 Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); &#125; &#125; );//创建观察者 Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Toast.makeText(SecondActivity.this, s ,Toast.LENGTH_SHORT).show(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;;//订阅 myObservable.subscribe(mySubscriber); 简化写法1234567891011121314151617181920212223Observable&lt;String&gt; myObservable = Observable.just(&quot;hellow simple&quot;);Action1&lt;String&gt; onNextAction=new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Toast.makeText(SecondActivity.this, s, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,s); &#125;&#125;;Action1&lt;Throwable&gt; onError=new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Toast.makeText(SecondActivity.this, &quot;error&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,&quot;error&quot;); &#125;&#125;;Action0 onCompleted=new Action0() &#123; @Override public void call() &#123; Toast.makeText(SecondActivity.this, &quot;completed&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,&quot;completed&quot;); &#125;&#125;;myObservable.subscribe(onNextAction,onError,onCompleted); RxJava还提供了简化写法，Observable.just()可以有多个Object参数，相当于实现了多次onNext(Object o)和一次onCompleted()。 操作符的使用大量的操作符是RxJava实现逻辑清晰的关键，他能将复杂的逻辑操作分散开来，使每一步的结果都清晰可见。接下来介绍几个常用的操作符 map对于事件作进一步处理,用于一对一的转化123456789101112131415Observable&lt;String&gt; myObservable = Observable.just(&quot;hellow simple&quot;); Observable&lt;String&gt; myObservableMap=myObservable.map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s+&quot;-xu&quot;; &#125; &#125;); Action1&lt;String&gt; onNextAction=new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Toast.makeText(SecondActivity.this, s, Toast.LENGTH_SHORT).show(); Log.i(&quot;tag&quot;,s); &#125; &#125;; myObservableMap.subscribe(onNextAction); fromfrom标签相当于调用了多次onNext(Object o)一次onCompleted()12345678910111213141516171819from标签相当于调用了多次onNext(Object o)一次onCompleted() String[] words = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; Observable&lt;String&gt; observable = Observable.from(words); observable.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(&quot;form&quot;, s); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i(&quot;from&quot;, &quot;error&quot;); &#125; &#125;, new Action0() &#123; @Override public void call() &#123; Log.i(&quot;from&quot;,&quot;complete&quot;); &#125; &#125;); flatMap与map不同的flatMap是用于一对多的转化12345678910111213141516List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); Observable&lt;List&lt;String&gt;&gt; observable=Observable.just(list); observable.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(List&lt;String&gt; strings) &#123; return Observable.from(strings); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(&quot;tag&quot;,s); &#125; &#125;); 线程控制几种线程的位置: Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行 变化线程操纵subscribeOn(Scheduler.io());事件产生的线程,作用在Observable.just(1, 2, 3, 4)，即Observable生成时，位置放在哪都可以，但只能调用一次observeOn(AndroidSchedulers.mainThread());事件消费的线程,用于Observable生成后的操作，可以多次调用实现线程的多次切换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable&lt;String&gt; observable=Observable.just(&quot;thread&quot;);observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map1___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).observeOn(Schedulers.io()).map(new Func1&lt;String,String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map2___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).map(new Func1&lt;String,String&gt;() &#123; @Override public String call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;,Thread.currentThread().getId()+&quot;map3___&quot;+System.currentTimeMillis()); return s; &#125;&#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(&quot;thread&quot;, Thread.currentThread().getId() + &quot;main___&quot;+System.currentTimeMillis()); &#125;&#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i(&quot;thread&quot;,&quot;wrong0&quot;); &#125;&#125;); 关于RxJava的功能还有很多我还未使用到，如果想要对RxJava有更多的了解可以参考以下几篇文章给 Android 开发者的 RxJava 详解深入浅出RxJavaAwesome-RxJava]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于键盘的一切]]></title>
    <url>%2F2016%2F09%2F09%2F%E5%85%B3%E4%BA%8E%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[1.windowSoftInputMode设置windowSoftInputMode的参数分为两种 限定进入Activity时键盘的状态(弹出还是隐藏) stateUnspecified：未指定的默认状态 stateUnchanged ：不改变键盘的状态——与上一个界面的键盘状态相同 stateHidden ：隐藏键盘 stateAlwaysHidden：隐藏键盘——进入下一个界面后返回还是隐藏键盘 stateVisible ：显示键盘 stateAlwaysVisible：显示键盘——进入下一个界面后返回还是显示键盘 设置键盘弹出时页面布局的改变的状态 adjustUnspecified：未指定的默认状态，自动适配屏幕 adjustResize ：Activity的主窗口总是会被调整大小，从而保证软键盘显示空间，键盘作为布局的一部分来展示 adjustPan ：利用布局移动来保证输入框在视野范围内 2.动态显示/隐藏键盘显示键盘 1234editText.setFocusableInTouchMode(true);editText.requestFocus();InputMethodManager inputManager =(InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);inputManager.showSoftInput(editText, 0); 隐藏键盘 12InputMethodManager inputManager =(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);inputManager.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); 3.键盘高度的监听当系统提供的adjustResize和adjustPan 不能满足页面布局设计的需求时可以通过监听键盘高度来动态改变布局123456789101112final View decorView= getWindow().getDecorView(); decorView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect=new Rect(); decorView.getWindowVisibleDisplayFrame(rect); int displayHeight=rect.bottom; int height=decorView.getHeight(); int keyboardHeight=height-displayHeight; Log.i("KEYBOARD","键盘的高度是"+keyboardHeight); &#125;&#125;); 4.改变键盘回车键显示和功能有时候需要改变键盘回车键来实现搜索、发送、完成等功能。12345678910111213141516171819// et.setImeOptions(EditorInfo.IME_ACTION_DONE);//完成// et.setImeOptions(EditorInfo.IME_ACTION_SEND);//发送// et.setImeOptions(EditorInfo.IME_ACTION_SEARCH);//搜索// et.setImeOptions(EditorInfo.IME_ACTION_GO);//前往// et.setImeOptions(EditorInfo.IME_ACTION_NEXT);//下一项// et.setImeOptions(EditorInfo.IME_ACTION_NONE);//默认// et.setImeOptions(EditorInfo.IME_ACTION_PREVIOUS);//上一项 et.setImeOptions(EditorInfo.IME_ACTION_UNSPECIFIED);//未指明 et.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View view, int i, KeyEvent keyEvent) &#123; if(i == KeyEvent.KEYCODE_ENTER &amp;&amp; keyEvent.getAction() == KeyEvent.ACTION_UP)&#123; Toast.makeText(MainActivity.this, &quot;按下了回车键&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; return false; &#125; &#125;); &#125; 最后，改变键盘回车键必须是singleLine的EditText才能实现]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>基础控件</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
</search>
